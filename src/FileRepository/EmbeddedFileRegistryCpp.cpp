/**
 * This file was generated by bin2cpp v2.2.0
 * Copyright (C) 2013-2019 end2endzone.com. All rights reserved.
 * bin2cpp is open source software, see http://github.com/end2endzone/bin2cpp
 * Source code for file 'Registry.cpp', last modified 1552247130.
 * Do not modify this file.
 */
#include "EmbeddedFileRegistryCpp.h"
#include <stdio.h> //for FILE
#include <string> //for memcpy
namespace bin2cpp
{
  class RegistryCppFile : public virtual bin2cpp::File
  {
  public:
    RegistryCppFile() { build(); }
    virtual ~RegistryCppFile() {}
    virtual size_t getSize() const { return 17499; }
    virtual const char * getFilename() const { return "Registry.cpp"; }
    virtual const char * getBuffer() const { return mBuffer.c_str(); }
    void build()
    {
      mBuffer.clear();
      mBuffer.reserve(getSize()); //allocate all required memory at once to prevent reallocations
      mBuffer.append("//\r\n// Registry.cpp\r\n//\r\n\r\n#include <shlwapi.h>\r\n#pragma comment(lib, \"shlwapi\" )\r\n\r\n//ATL includes are not supported by Visual Studio Express.\r\n//Using the following include files as an alternative:\r", 200);
      mBuffer.append("\n//#include <objbase.h> // ATL base\r\n//#include <atlbase.h>\r\n#include <assert.h>\r\n#include \"SmartPointers.h\" //replacement for <objbase.h> and <atlbase.h>\r\n#include <comdef.h>\r\n\r\n#include \"Registry.h\"", 200);
      mBuffer.append("\r\n\r\n\r\n////////////////////////////////////////////////////////\r\n//\r\n// Internal helper functions prototypes\r\n//\r\n\r\n// Set the given key and its value.\r\nBOOL setKeyAndValue(const char* pszPath,\r\n      ", 200);
      mBuffer.append("              const char* szSubkey,\r\n                    const char* szValue) ;\r\n\r\n\r\nBOOL setValue(const char* szKey,\r\n              const char* szEntry,\r\n              const char* szValue);\r\n\r\n\r\n// C", 200);
      mBuffer.append("onvert a CLSID into a char string.\r\nvoid CLSIDtochar(const CLSID& clsid, \r\n                 char* szCLSID,\r\n                 int length) ;\r\n\r\n// Delete szKeyChild and all of its descendents.\r\nLONG rec", 200);
      mBuffer.append("ursiveDeleteKey(HKEY hKeyParent, const char* szKeyChild) ;\r\n\r\n////////////////////////////////////////////////////////\r\n//\r\n// Constants\r\n//\r\n\r\n// Size of a CLSID as a string\r\nconst int CLSID_STRING_S", 200);
      mBuffer.append("IZE = 39 ;\r\n\r\n/////////////////////////////////////////////////////////\r\n//\r\n// Public function implementation\r\n//\r\n\r\n//\r\n// Register the component in the registry.\r\n//\r\nHRESULT RegisterServer(HMODULE", 200);
      mBuffer.append(" hModule,            // DLL module handle\r\n                       const CLSID& clsid,         // Class ID\r\n                       const char* szFriendlyName, // Friendly Name\r\n                       c", 200);
      mBuffer.append("onst char* szVerIndProgID, // Programmatic\r\n                       const char* szProgID,\r\n\t\t\t\t\t             const CLSID &libid)         // Type lib ID\r\n{\r\n\t// Get server location.\r\n\tchar szModule[1024", 200);
      mBuffer.append("];\r\n\tDWORD dwResult =\r\n\t\t::GetModuleFileName(hModule, \r\n\t\t                    szModule,\r\n\t\t                    sizeof(szModule)/sizeof(char)) ;\r\n\tassert(dwResult != 0) ;\r\n\r\n\t// Convert the CLSID into ", 200);
      mBuffer.append("a char.\r\n\tchar szCLSID[CLSID_STRING_SIZE] ;\r\n\tCLSIDtochar(clsid, szCLSID, sizeof(szCLSID)) ;\r\n\tchar szLIBID[CLSID_STRING_SIZE] ;\r\n\tCLSIDtochar(libid, szLIBID, sizeof(szLIBID)) ;\r\n\r\n\t// Build the key C", 200);
      mBuffer.append("LSID\\\\{...}\r\n\tchar szKey[64] ;\r\n\tstrcpy(szKey, \"CLSID\\\\\") ;\r\n\tstrcat(szKey, szCLSID) ;\r\n  \r\n\t// Add the CLSID to the registry.\r\n\tsetKeyAndValue(szKey, NULL, szFriendlyName) ;\r\n\r\n\t// Add the server fil", 200);
      mBuffer.append("ename subkey under the CLSID key.\r\n\tchar szModuleExeOrDll[4];\r\n\tlong nLength = strlen(szModule);\r\n\tstrncpy(szModuleExeOrDll, szModule+nLength-3, 3);\r\n\tszModuleExeOrDll[3] = 0;\r\n\tif (_stricmp(szModuleE", 200);
      mBuffer.append("xeOrDll,\"exe\")==0)\r\n\t\tsetKeyAndValue(szKey, \"LocalServer32\", szModule) ;\r\n\telse\r\n\t{\r\n\t\tsetKeyAndValue(szKey, \"InProcServer32\", szModule) ;\r\n\t\tchar szKeyInProc[64];\r\n\t\tstrcpy(szKeyInProc, szKey);\r\n\t\tst", 200);
      mBuffer.append("rcat(szKeyInProc, \"\\\\InProcServer32\");\r\n\t\tsetValue(szKeyInProc, \"ThreadingModel\", \"Both\") ;\r\n\t}\r\n\r\n\t// Add the ProgID subkey under the CLSID key.\r\n\tsetKeyAndValue(szKey, \"ProgID\", szProgID) ;\r\n\r\n\t// A", 200);
      mBuffer.append("dd the version-independent ProgID subkey under CLSID key.\r\n\tsetKeyAndValue(szKey, \"VersionIndependentProgID\", szVerIndProgID) ;\r\n\r\n\t// Add the typelib\r\n\tsetKeyAndValue(szKey, \"TypeLib\", szLIBID) ;\r\n\r\n", 200);
      mBuffer.append("\r\n\t// Add the version-independent ProgID subkey under HKEY_CLASSES_ROOT.\r\n\tsetKeyAndValue(szVerIndProgID, NULL, szFriendlyName) ; \r\n\tsetKeyAndValue(szVerIndProgID, \"CLSID\", szCLSID) ;\r\n\tsetKeyAndValue", 200);
      mBuffer.append("(szVerIndProgID, \"CurVer\", szProgID) ;\r\n\r\n\t// Add the versioned ProgID subkey under HKEY_CLASSES_ROOT.\r\n\tsetKeyAndValue(szProgID, NULL, szFriendlyName) ; \r\n\tsetKeyAndValue(szProgID, \"CLSID\", szCLSID) ", 200);
      mBuffer.append(";\r\n\r\n\t// add TypeLib keys\r\n\tstrcpy(szKey, \"TypeLib\\\\\") ;\r\n\tstrcat(szKey, szLIBID) ;\r\n\r\n\t// Add the CLSID to the registry.\r\n\tsetKeyAndValue(szKey, NULL, NULL) ;\r\n\tstrcat(szKey, \"\\\\1.0\");\r\n\tsetKeyAndVal", 200);
      mBuffer.append("ue(szKey, NULL, szFriendlyName) ;\r\n\tstrcat(szKey, \"\\\\0\");\r\n\tsetKeyAndValue(szKey, NULL, NULL) ;\r\n\tstrcat(szKey, \"\\\\win32\");\r\n\tsetKeyAndValue(szKey, NULL, szModule) ;\r\n\r\n\r\n\treturn S_OK ;\r\n}\r\n\r\n\r\nvoid R", 200);
      mBuffer.append("egisterInterface(HMODULE hModule,            // DLL module handle\r\n                       const CLSID& clsid,         // Class ID\r\n                       const char* szFriendlyName, // Friendly Name\r\n", 200);
      mBuffer.append("\t\t\t\t\t             const CLSID &libid,\r\n\t\t\t\t\t             const IID &iid)\r\n{\r\n\t// Get server location.\r\n\tchar szModule[512] ;\r\n\tDWORD dwResult =\r\n\t\t::GetModuleFileName(hModule, \r\n\t\t                    ", 200);
      mBuffer.append("szModule,\r\n\t\t                    sizeof(szModule)/sizeof(char)) ;\r\n\tassert(dwResult != 0) ;\r\n\r\n\t// Convert the CLSID into a char.\r\n\tchar szCLSID[CLSID_STRING_SIZE] ;\r\n\tCLSIDtochar(clsid, szCLSID, size", 200);
      mBuffer.append("of(szCLSID)) ;\r\n\tchar szLIBID[CLSID_STRING_SIZE] ;\r\n\tCLSIDtochar(libid, szLIBID, sizeof(szCLSID)) ;\r\n\tchar szIID[CLSID_STRING_SIZE] ;\r\n\tCLSIDtochar(iid, szIID, sizeof(szCLSID)) ;\r\n\r\n\t// Build the key ", 200);
      mBuffer.append("Interface\\\\{...}\r\n\tchar szKey[64] ;\r\n\tstrcpy(szKey, \"Interface\\\\\") ;\r\n\tstrcat(szKey, szIID) ;\r\n  \r\n\t// Add the value to the registry.\r\n\tsetKeyAndValue(szKey, NULL, szFriendlyName) ;\r\n\r\n\tchar szKey2[MA", 200);
      mBuffer.append("X_PATH];\r\n\tstrcpy(szKey2, szKey);\r\n\tstrcat(szKey2, \"\\\\ProxyStubClsID\");\r\n\t// Add the server filename subkey under the IID key.\r\n\tsetKeyAndValue(szKey2, NULL, \"{00020424-0000-0000-C000-000000000046}\");", 200);
      mBuffer.append(" //IUnknown\r\n\r\n\tstrcpy(szKey2, szKey);\r\n\tstrcat(szKey2, \"\\\\ProxyStubClsID32\");\r\n\t// Add the server filename subkey under the IID key.\r\n\tsetKeyAndValue(szKey2, NULL, \"{00020424-0000-0000-C000-000000000", 200);
      mBuffer.append("046}\"); //IUnknown\r\n\r\n\tstrcpy(szKey2, szKey);\r\n\tstrcat(szKey2, \"\\\\TypeLib\");\r\n\t// Add the server filename subkey under the CLSID key.\r\n\tsetKeyAndValue(szKey2, NULL, szLIBID) ;\r\n\t\r\n\tsetValue(szKey2, \"V", 200);
      mBuffer.append("ersion\", \"1.0\") ;\r\n}\r\n\r\nvoid UnregisterInterface(const IID &iid)\r\n{\r\n\tchar szIID[CLSID_STRING_SIZE] ;\r\n\tCLSIDtochar(iid, szIID, sizeof(szIID)) ;\r\n\r\n\t// Build the key Interface\\\\{...}\r\n\tchar szKey[64] ", 200);
      mBuffer.append(";\r\n\tstrcpy(szKey, \"Interface\\\\\") ;\r\n\tstrcat(szKey, szIID) ;\r\n\r\n\tLONG lResult = recursiveDeleteKey(HKEY_CLASSES_ROOT, szKey) ;\r\n}\r\n\r\n//\r\n// Remove the component from the registry.\r\n//\r\nLONG UnregisterS", 200);
      mBuffer.append("erver(const CLSID& clsid,         // Class ID\r\n                      const char* szVerIndProgID, // Programmatic\r\n                      const char* szProgID,\r\n\t\t\t\t\t            const CLSID &libid)     ", 200);
      mBuffer.append("    // Type lib ID\r\n{\r\n\t// Convert the CLSID into a char.\r\n\tchar szCLSID[CLSID_STRING_SIZE] ;\r\n\tCLSIDtochar(clsid, szCLSID, sizeof(szCLSID)) ;\r\n\r\n\t// Build the key CLSID\\\\{...}\r\n\tchar szKey[64] ;\r\n\tst", 200);
      mBuffer.append("rcpy(szKey, \"CLSID\\\\\") ;\r\n\tstrcat(szKey, szCLSID) ;\r\n\r\n\t// Delete the CLSID Key - CLSID\\{...}\r\n\tLONG lResult = recursiveDeleteKey(HKEY_CLASSES_ROOT, szKey) ;\r\n\tassert((lResult == ERROR_SUCCESS) ||\r\n\t ", 200);
      mBuffer.append("      (lResult == ERROR_FILE_NOT_FOUND)) ; // Subkey may not exist.\r\n\r\n\t// Delete the version-independent ProgID Key.\r\n\tlResult = recursiveDeleteKey(HKEY_CLASSES_ROOT, szVerIndProgID) ;\r\n\tassert((lRes", 200);
      mBuffer.append("ult == ERROR_SUCCESS) ||\r\n\t       (lResult == ERROR_FILE_NOT_FOUND)) ; // Subkey may not exist.\r\n\r\n\t// Delete the ProgID key.\r\n\tlResult = recursiveDeleteKey(HKEY_CLASSES_ROOT, szProgID) ;\r\n\tassert((lR", 200);
      mBuffer.append("esult == ERROR_SUCCESS) ||\r\n\t       (lResult == ERROR_FILE_NOT_FOUND)) ; // Subkey may not exist.\r\n\r\n\tchar szLIBID[CLSID_STRING_SIZE] ;\r\n\tCLSIDtochar(libid, szLIBID, sizeof(szLIBID)) ;\r\n\t\r\n\tstrcpy(szK", 200);
      mBuffer.append("ey, \"TypeLib\\\\\") ;\r\n\tstrcat(szKey, szLIBID) ;\r\n\r\n\t// Delete the TypeLib Key - LIBID\\{...}\r\n\tlResult = recursiveDeleteKey(HKEY_CLASSES_ROOT, szKey) ;\r\n\tassert((lResult == ERROR_SUCCESS) ||\r\n\t       (lR", 200);
      mBuffer.append("esult == ERROR_FILE_NOT_FOUND)) ; // Subkey may not exist.\r\n\r\n\treturn S_OK ;\r\n}\r\n\r\n///////////////////////////////////////////////////////////\r\n//\r\n// Internal helper functions\r\n//\r\n\r\n// Convert a CLS", 200);
      mBuffer.append("ID to a char string.\r\nvoid CLSIDtochar(const CLSID& clsid,\r\n                 char* szCLSID,\r\n                 int length)\r\n{\r\n\tassert(length >= CLSID_STRING_SIZE) ;\r\n\t// Get CLSID\r\n\tLPOLESTR wszCLSID ", 200);
      mBuffer.append("= NULL ;\r\n\tHRESULT hr = StringFromCLSID(clsid, &wszCLSID) ;\r\n\tassert(SUCCEEDED(hr)) ;\r\n\r\n\t// Covert from wide characters to non-wide.\r\n\twcstombs(szCLSID, wszCLSID, length) ;\r\n\r\n\t// Free memory.\r\n\tCoTa", 200);
      mBuffer.append("skMemFree(wszCLSID) ;\r\n}\r\n\r\n//\r\n// Delete a key and all of its descendents.\r\n//\r\nLONG recursiveDeleteKey(HKEY hKeyParent,           // Parent of key to delete\r\n                        const char* lpsz", 200);
      mBuffer.append("KeyChild)  // Key to delete\r\n{\r\n\t// Open the child.\r\n\tHKEY hKeyChild ;\r\n\tLONG lRes = RegOpenKeyEx(hKeyParent, lpszKeyChild, 0,\r\n\t                         KEY_ALL_ACCESS, &hKeyChild) ;\r\n\tif (lRes != ER", 200);
      mBuffer.append("ROR_SUCCESS)\r\n\t{\r\n\t\treturn lRes ;\r\n\t}\r\n\r\n\t// Enumerate all of the decendents of this child.\r\n\tFILETIME time ;\r\n\tchar szBuffer[256] ;\r\n\tDWORD dwSize = 256 ;\r\n\twhile (RegEnumKeyEx(hKeyChild, 0, szBuffer", 200);
      mBuffer.append(", &dwSize, NULL,\r\n\t                    NULL, NULL, &time) == S_OK)\r\n\t{\r\n\t\t// Delete the decendents of this child.\r\n\t\tlRes = recursiveDeleteKey(hKeyChild, szBuffer) ;\r\n\t\tif (lRes != ERROR_SUCCESS)\r\n\t\t{", 200);
      mBuffer.append("\r\n\t\t\t// Cleanup before exiting.\r\n\t\t\tRegCloseKey(hKeyChild) ;\r\n\t\t\treturn lRes;\r\n\t\t}\r\n\t\tdwSize = 256 ;\r\n\t}\r\n\r\n\t// Close the child.\r\n\tRegCloseKey(hKeyChild) ;\r\n\r\n\t// Delete this child.\r\n\treturn RegDelete", 200);
      mBuffer.append("Key(hKeyParent, lpszKeyChild) ;\r\n}\r\n\r\n//\r\n// Create a key and set its value.\r\n//   - This helper function was borrowed and modifed from\r\n//     Kraig Brockschmidt\'s book Inside OLE.\r\n//\r\nBOOL setKeyAn", 200);
      mBuffer.append("dValue(const char* szKey,\r\n                    const char* szSubkey,\r\n                    const char* szValue)\r\n{\r\n\tHKEY hKey;\r\n\tchar szKeyBuf[1024] ;\r\n\r\n\t// Copy keyname into buffer.\r\n\tstrcpy(szKeyBu", 200);
      mBuffer.append("f, szKey) ;\r\n\r\n\t// Add subkey name to buffer.\r\n\tif (szSubkey != NULL)\r\n\t{\r\n\t\tstrcat(szKeyBuf, \"\\\\\") ;\r\n\t\tstrcat(szKeyBuf, szSubkey ) ;\r\n\t}\r\n\r\n\t// Create and open key and subkey.\r\n\tlong lResult = RegCr", 200);
      mBuffer.append("eateKeyEx(HKEY_CLASSES_ROOT ,\r\n\t                              szKeyBuf, \r\n\t                              0, NULL, REG_OPTION_NON_VOLATILE,\r\n\t                              KEY_ALL_ACCESS, NULL, \r\n\t    ", 200);
      mBuffer.append("                          &hKey, NULL) ;\r\n\tif (lResult != ERROR_SUCCESS)\r\n\t{\r\n\t\treturn FALSE ;\r\n\t}\r\n\r\n\t// Set the Value.\r\n\tif (szValue != NULL)\r\n\t{\r\n\t\tRegSetValueEx(hKey, NULL, 0, REG_SZ, \r\n\t\t        ", 200);
      mBuffer.append("      (BYTE *)szValue, \r\n\t\t              DWORD( 1+strlen(szValue) ) \r\n\t\t) ;\r\n\t}\r\n\r\n\tRegCloseKey(hKey) ;\r\n\treturn TRUE ;\r\n}\r\n\r\n\r\nBOOL setValue(const char* szKey,\r\n              const char* szEntry,\r\n  ", 200);
      mBuffer.append("            const char* szValue)\r\n{\r\n\tHKEY hKey;\r\n\r\n\t// Create and open key and subkey.\r\n\tlong lResult = RegOpenKeyEx(HKEY_CLASSES_ROOT ,\r\n\t                              szKey, \r\n\t                    ", 200);
      mBuffer.append("          0, \r\n\t                              KEY_ALL_ACCESS, \r\n\t\t\t\t\t\t\t\t  &hKey) ;\r\n\tif (lResult != ERROR_SUCCESS)\r\n\t{\r\n\t\treturn FALSE ;\r\n\t}\r\n\r\n\t// Set the Value.\r\n\tif (szValue != NULL)\r\n\t{\r\n\t\tRegSetV", 200);
      mBuffer.append("alueEx(hKey, szEntry, 0, REG_SZ, \r\n\t\t              (BYTE *)szValue, \r\n\t\t              DWORD( 1+strlen(szValue) )\r\n\t\t) ;\r\n\t}\r\n\r\n\tRegCloseKey(hKey) ;\r\n\r\n\treturn TRUE;\r\n}\r\n\r\n\r\n\r\n/////////////////////////", 200);
      mBuffer.append("////////////////////////////////////////////////////\r\n// TypeLib registration\r\n\r\nHRESULT LoadTypeLib(HINSTANCE hInstTypeLib, LPCOLESTR lpszIndex, BSTR* pbstrPath, ITypeLib** ppTypeLib)\r\n{\r\n\tATLASSERT(", 200);
      mBuffer.append("pbstrPath != NULL && ppTypeLib != NULL);\r\n\tif (pbstrPath == NULL || ppTypeLib == NULL)\r\n\t\treturn E_POINTER;\r\n\r\n\t*pbstrPath = NULL;\r\n\t*ppTypeLib = NULL;\r\n\r\n\tUSES_CONVERSION;\r\n\tATLASSERT(hInstTypeLib !=", 200);
      mBuffer.append(" NULL);\r\n\tTCHAR szModule[MAX_PATH+10];\r\n\r\n\tDWORD dwFLen = ::GetModuleFileName(hInstTypeLib, szModule, MAX_PATH);\r\n\tif( dwFLen == 0 )\r\n\t\treturn HRESULT_FROM_WIN32(::GetLastError());\r\n\telse if( dwFLen =", 200);
      mBuffer.append("= MAX_PATH )\r\n\t\treturn HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);\r\n\r\n\t// get the extension pointer in case of fail\r\n\tLPTSTR lpszExt = NULL;\r\n\r\n\tlpszExt = ::PathFindExtension(szModule);\r\n\r\n\tif (lps", 200);
      mBuffer.append("zIndex != NULL)\r\n\t\tlstrcat(szModule, OLE2CT(lpszIndex));\r\n\tLPOLESTR lpszModule = T2OLE(szModule);\r\n\tHRESULT hr = ::LoadTypeLib(lpszModule, ppTypeLib);\r\n\tif (!SUCCEEDED(hr))\r\n\t{\r\n\t\t// typelib not in mo", 200);
      mBuffer.append("dule, try <module>.tlb instead\r\n\t\tlstrcpy(lpszExt, _T(\".tlb\"));\r\n\t\tlpszModule = T2OLE(szModule);\r\n\t\thr = ::LoadTypeLib(lpszModule, ppTypeLib);\r\n\t}\r\n\tif (SUCCEEDED(hr))\r\n\t{\r\n\t\t*pbstrPath = ::SysAllocSt", 200);
      mBuffer.append("ring(lpszModule);\r\n\t\tif (*pbstrPath == NULL)\r\n\t\t\thr = E_OUTOFMEMORY;\r\n\t}\r\n\treturn hr;\r\n}\r\n\r\nstatic inline UINT WINAPI GetDirLen(LPCOLESTR lpszPathName) throw()\r\n{\r\n\tATLASSERT(lpszPathName != NULL);\r\n\r", 200);
      mBuffer.append("\n\t// always capture the complete file name including extension (if present)\r\n\tLPCOLESTR lpszTemp = lpszPathName;\r\n\tfor (LPCOLESTR lpsz = lpszPathName; *lpsz != NULL; )\r\n\t{\r\n\t\tLPCOLESTR lp = CharNextO(", 200);
      mBuffer.append("lpsz);\r\n\t\t// remember last directory/drive separator\r\n\t\tif (*lpsz == OLESTR(\'\\\\\') || *lpsz == OLESTR(\'/\') || *lpsz == OLESTR(\':\'))\r\n\t\t\tlpszTemp = lp;\r\n\t\tlpsz = lp;\r\n\t}\r\n\r\n\treturn UINT( lpszTemp-lpszPa", 200);
      mBuffer.append("thName );\r\n}\r\n\r\n\r\nHRESULT RegisterTypeLib(HINSTANCE hInstTypeLib, LPCOLESTR lpszIndex)\r\n{\r\n\tCComBSTR bstrPath;\r\n\tCComPtr<ITypeLib> pTypeLib;\r\n\tHRESULT hr = LoadTypeLib(hInstTypeLib, lpszIndex, &bstrPa", 200);
      mBuffer.append("th, &pTypeLib);\r\n\tif (SUCCEEDED(hr))\r\n\t{\r\n\t\tOLECHAR szDir[MAX_PATH];\r\n\t\tocscpy(szDir, bstrPath);\r\n\t\t// If index is specified remove it from the path\r\n\t\tif (lpszIndex != NULL)\r\n\t\t{\r\n\t\t\tsize_t nLenPath ", 200);
      mBuffer.append("= ocslen(szDir);\r\n\t\t\tsize_t nLenIndex = ocslen(lpszIndex);\r\n\t\t\tif (memcmp(szDir + nLenPath - nLenIndex, lpszIndex, nLenIndex) == 0)\r\n\t\t\t\tszDir[nLenPath - nLenIndex] = 0;\r\n\t\t}\r\n\t\tszDir[GetDirLen(szDir)", 200);
      mBuffer.append("] = 0;\r\n\t\thr = ::RegisterTypeLib(pTypeLib, bstrPath, szDir);\r\n\t}\r\n\treturn hr;\r\n}\r\n\r\nHRESULT UnRegisterTypeLib(HINSTANCE hInstTypeLib, LPCOLESTR lpszIndex)\r\n{\r\n\tCComBSTR bstrPath;\r\n\tCComPtr<ITypeLib> p", 200);
      mBuffer.append("TypeLib;\r\n\tHRESULT hr = LoadTypeLib(hInstTypeLib, lpszIndex, &bstrPath, &pTypeLib);\r\n\tif (SUCCEEDED(hr))\r\n\t{\r\n\t\tTLIBATTR* ptla;\r\n\t\thr = pTypeLib->GetLibAttr(&ptla);\r\n\t\tif (SUCCEEDED(hr))\r\n\t\t{\r\n\t\t\thr =", 200);
      mBuffer.append(" ::UnRegisterTypeLib(ptla->guid, ptla->wMajorVerNum, ptla->wMinorVerNum, ptla->lcid, ptla->syskind);\r\n\t\t\tpTypeLib->ReleaseTLibAttr(ptla);\r\n\t\t}\r\n\t}\r\n\treturn hr;\r\n}\r\n\r\nchar *rstrstr(char * _Str, char * ", 200);
      mBuffer.append("_SubStr)\r\n{\r\n  size_t  s1len = strlen(_Str);\r\n  size_t  s2len = strlen(_SubStr);\r\n  char *s;\r\n\r\n  if (s2len > s1len)\r\n    return NULL;\r\n  for (s = _Str + s1len - s2len; s >= _Str; --s)\r\n    if (strncm", 200);
      mBuffer.append("p(s, _SubStr, s2len) == 0)\r\n      return s;\r\n  return NULL;\r\n}\r\n\r\nHRESULT RegisterServer(HMODULE hModule,\r\n                       const char* szAppID,\r\n                       const CLSID& clsid,\r\n    ", 200);
      mBuffer.append("                   const char* szFriendlyName,\r\n                       const char* szVerIndProgID,\r\n                       const char* szProgID,\r\n\t\t\t\t\t             const CLSID& libid)\r\n{\r\n  // Get ser", 200);
      mBuffer.append("ver location.\r\n  char szModule[1024];\r\n  DWORD dwResult =\r\n\t  ::GetModuleFileName(hModule, \r\n\t\t                    szModule,\r\n\t\t                    sizeof(szModule)/sizeof(char)) ;\r\n  assert(dwResult ", 200);
      mBuffer.append("!= 0) ;\r\n  long nModuleLength = strlen(szModule);\r\n\r\n  // Get server filename\r\n  char * szModuleFilename = rstrstr(szModule, \"\\\\\");\r\n  assert(szModuleFilename != 0) ;\r\n  szModuleFilename++; //skip \\ c", 200);
      mBuffer.append("haracter\r\n  long nFilenameLength = strlen(szModuleFilename);\r\n\r\n  // Get server filename extension\r\n  char * szExtension = rstrstr(szModule, \".\");\r\n  assert(szExtension != 0) ;\r\n  long nExtensionLengt", 200);
      mBuffer.append("h = strlen(szExtension);\r\n\r\n  // Get server filename (without extension)\r\n  char szModuleFilenameOnly[64];\r\n  strncpy(szModuleFilenameOnly, szModuleFilename, nFilenameLength-nExtensionLength);\r\n  szMo", 200);
      mBuffer.append("duleFilenameOnly[nFilenameLength-nExtensionLength] = 0;\r\n\r\n  // Build the key AppID\\\\{filename.exe}\r\n  char szKey[64] ;\r\n  strcpy(szKey, \"AppID\\\\\") ;\r\n  strcat(szKey, szModuleFilename) ;\r\n  \r\n  // Add", 200);
      mBuffer.append(" the AppID to the registry.\r\n  setKeyAndValue(szKey, NULL, NULL) ;\r\n  setValue(szKey, \"AppID\", szAppID) ;\r\n\r\n  // Build the key AppID\\\\{GUID}\r\n  strcpy(szKey, \"AppID\\\\\") ;\r\n  strcat(szKey, szAppID) ;\r", 200);
      mBuffer.append("\n  \r\n  // Add the AppID to the registry.\r\n  setKeyAndValue(szKey, NULL, szModuleFilenameOnly) ;\r\n\r\n  HRESULT hr = RegisterServer(hModule, clsid, szFriendlyName, szVerIndProgID, szProgID, libid);\r\n  re", 200);
      mBuffer.append("turn hr;\r\n}\r\n\r\nHRESULT UnregisterServer(HMODULE hModule,\r\n                         const char* szAppID,\r\n                         const CLSID& clsid,\r\n                         const char* szVerIndProg", 200);
      mBuffer.append("ID,\r\n                         const char* szProgID,\r\n\t\t\t\t\t\t             const CLSID& libid)\r\n{\r\n  // Get server location.\r\n  char szModule[1024];\r\n  DWORD dwResult =\r\n\t  ::GetModuleFileName(hModule, \r", 200);
      mBuffer.append("\n\t\t                    szModule,\r\n\t\t                    sizeof(szModule)/sizeof(char)) ;\r\n  assert(dwResult != 0) ;\r\n  long nModuleLength = strlen(szModule);\r\n\r\n  // Get server filename\r\n  char * szMo", 200);
      mBuffer.append("duleFilename = rstrstr(szModule, \"\\\\\");\r\n  assert(szModuleFilename != 0) ;\r\n  szModuleFilename++; //skip \\ character\r\n  long nFilenameLength = strlen(szModuleFilename);\r\n\r\n  // Get server filename ext", 200);
      mBuffer.append("ension\r\n  char * szExtension = rstrstr(szModule, \".\");\r\n  assert(szExtension != 0) ;\r\n  long nExtensionLength = strlen(szExtension);\r\n\r\n  // Build the key AppID\\\\{filename.exe}\r\n  char szKey[64] ;\r\n  ", 200);
      mBuffer.append("strcpy(szKey, \"AppID\\\\\") ;\r\n  strcat(szKey, szModuleFilename) ;\r\n  \r\n  // Delete the AppID Key - AppID\\{filename.exe}\r\n  LONG lResult = recursiveDeleteKey(HKEY_CLASSES_ROOT, szKey) ;\r\n  assert((lResul", 200);
      mBuffer.append("t == ERROR_SUCCESS) ||\r\n\t       (lResult == ERROR_FILE_NOT_FOUND)) ; // Subkey may not exist.\r\n\r\n  // Build the key AppID\\\\{GUID}\r\n  strcpy(szKey, \"AppID\\\\\") ;\r\n  strcat(szKey, szAppID) ;\r\n  \r\n  // De", 200);
      mBuffer.append("lete the AppID Key - AppID\\{GUID}\r\n  lResult = recursiveDeleteKey(HKEY_CLASSES_ROOT, szKey) ;\r\n  assert((lResult == ERROR_SUCCESS) ||\r\n\t       (lResult == ERROR_FILE_NOT_FOUND)) ; // Subkey may not ex", 200);
      mBuffer.append("ist.\r\n\r\n  HRESULT hr = UnregisterServer(clsid, szVerIndProgID, szProgID, libid);\r\n  return hr;\r\n}\r\n", 99);
    }
    virtual bool save(const char * iFilename) const
    {
      FILE * f = fopen(iFilename, "wb");
      if (!f) return false;
      size_t fileSize = getSize();
      const char * buffer = getBuffer();
      fwrite(buffer, 1, fileSize, f);
      fclose(f);
      return true;
    }
  private:
    std::string mBuffer;
  };
  const File & getRegistryCppFile() { static RegistryCppFile _instance; return _instance; }
}; //bin2cpp
