/**
 * This file was generated by
 * bin2cpp v1.3.
 * Copyright (C) 2013-2014 end2endzone.com. All rights reserved.
 * Do not modify this file.
 */
#include ".\EmbeddedFileRegistryCpp.h"
#include <stdio.h> //for FILE
#include <string> //for memcpy
namespace bin2cpp
{
  class RegistryCppFile : public virtual bin2cpp::File
  {
  public:
    RegistryCppFile() {}
    ~RegistryCppFile() {}
    virtual size_t getSize() { return 17499; }
    virtual size_t getSegmentSize() { return 200; }
    virtual size_t getNumSegments() { return 88; }
    virtual const char * getFilename() { return "Registry.cpp"; }
    virtual const char * getSegment(size_t iIndex, size_t & oLength)
    {
      oLength = 0;
      if (iIndex >= getNumSegments())
        return NULL;
      const char * buffer = NULL;
      size_t index = 0;
      oLength = getSegmentSize();
      buffer = "//\x0d\012// Registry.cpp\x0d\012//\x0d\x0a\x0d\012#include <shlwapi.h>\x0d\012#pragma comment(lib, \"shlwapi\" )\x0d\x0a\x0d\012//ATL includes are not supported by Visual Studio Express.\x0d\012//Using the following include files as an alternative:\x0d"; if (iIndex == index) return buffer; index++;
      buffer = "\012//#include <objbase.h> // ATL base\x0d\012//#include <atlbase.h>\x0d\012#include <assert.h>\x0d\012#include \"SmartPointers.h\" //replacement for <objbase.h> and <atlbase.h>\x0d\012#include <comdef.h>\x0d\x0a\x0d\012#include \"Registry.h\""; if (iIndex == index) return buffer; index++;
      buffer = "\x0d\x0a\x0d\x0a\x0d\012////////////////////////////////////////////////////////\x0d\012//\x0d\012// Internal helper functions prototypes\x0d\012//\x0d\x0a\x0d\012// Set the given key and its value.\x0d\012BOOL setKeyAndValue(const char* pszPath,\x0d\012      "; if (iIndex == index) return buffer; index++;
      buffer = "              const char* szSubkey,\x0d\012                    const char* szValue) ;\x0d\x0a\x0d\x0a\x0d\012BOOL setValue(const char* szKey,\x0d\012              const char* szEntry,\x0d\012              const char* szValue);\x0d\x0a\x0d\x0a\x0d\012// C"; if (iIndex == index) return buffer; index++;
      buffer = "onvert a CLSID into a char string.\x0d\012void CLSIDtochar(const CLSID& clsid, \x0d\012                 char* szCLSID,\x0d\012                 int length) ;\x0d\x0a\x0d\012// Delete szKeyChild and all of its descendents.\x0d\012LONG rec"; if (iIndex == index) return buffer; index++;
      buffer = "ursiveDeleteKey(HKEY hKeyParent, const char* szKeyChild) ;\x0d\x0a\x0d\012////////////////////////////////////////////////////////\x0d\012//\x0d\012// Constants\x0d\012//\x0d\x0a\x0d\012// Size of a CLSID as a string\x0d\012const int CLSID_STRING_S"; if (iIndex == index) return buffer; index++;
      buffer = "IZE = 39 ;\x0d\x0a\x0d\012/////////////////////////////////////////////////////////\x0d\012//\x0d\012// Public function implementation\x0d\012//\x0d\x0a\x0d\012//\x0d\012// Register the component in the registry.\x0d\012//\x0d\012HRESULT RegisterServer(HMODULE"; if (iIndex == index) return buffer; index++;
      buffer = " hModule,            // DLL module handle\x0d\012                       const CLSID& clsid,         // Class ID\x0d\012                       const char* szFriendlyName, // Friendly Name\x0d\012                       c"; if (iIndex == index) return buffer; index++;
      buffer = "onst char* szVerIndProgID, // Programmatic\x0d\012                       const char* szProgID,\x0d\x0a\t\t\t\t\t             const CLSID &libid)         // Type lib ID\x0d\012{\x0d\x0a\t// Get server location.\x0d\x0a\tchar szModule[1024"; if (iIndex == index) return buffer; index++;
      buffer = "];\x0d\x0a\tDWORD dwResult =\x0d\x0a\t\t::GetModuleFileName(hModule, \x0d\x0a\t\t                    szModule,\x0d\x0a\t\t                    sizeof(szModule)/sizeof(char)) ;\x0d\x0a\tassert(dwResult != 0) ;\x0d\x0a\x0d\x0a\t// Convert the CLSID into "; if (iIndex == index) return buffer; index++;
      buffer = "a char.\x0d\x0a\tchar szCLSID[CLSID_STRING_SIZE] ;\x0d\x0a\tCLSIDtochar(clsid, szCLSID, sizeof(szCLSID)) ;\x0d\x0a\tchar szLIBID[CLSID_STRING_SIZE] ;\x0d\x0a\tCLSIDtochar(libid, szLIBID, sizeof(szLIBID)) ;\x0d\x0a\x0d\x0a\t// Build the key C"; if (iIndex == index) return buffer; index++;
      buffer = "LSID\\\\{...}\x0d\x0a\tchar szKey[64] ;\x0d\x0a\tstrcpy(szKey, \"CLSID\\\\\") ;\x0d\x0a\tstrcat(szKey, szCLSID) ;\x0d\012  \x0d\x0a\t// Add the CLSID to the registry.\x0d\x0a\tsetKeyAndValue(szKey, NULL, szFriendlyName) ;\x0d\x0a\x0d\x0a\t// Add the server fil"; if (iIndex == index) return buffer; index++;
      buffer = "ename subkey under the CLSID key.\x0d\x0a\tchar szModuleExeOrDll[4];\x0d\x0a\tlong nLength = strlen(szModule);\x0d\x0a\tstrncpy(szModuleExeOrDll, szModule+nLength-3, 3);\x0d\x0a\tszModuleExeOrDll[3] = 0;\x0d\x0a\tif (_stricmp(szModuleE"; if (iIndex == index) return buffer; index++;
      buffer = "xeOrDll,\"exe\")==0)\x0d\x0a\t\tsetKeyAndValue(szKey, \"LocalServer32\", szModule) ;\x0d\x0a\telse\x0d\x0a\t{\x0d\x0a\t\tsetKeyAndValue(szKey, \"InProcServer32\", szModule) ;\x0d\x0a\t\tchar szKeyInProc[64];\x0d\x0a\t\tstrcpy(szKeyInProc, szKey);\x0d\x0a\t\tst"; if (iIndex == index) return buffer; index++;
      buffer = "rcat(szKeyInProc, \"\\\\InProcServer32\");\x0d\x0a\t\tsetValue(szKeyInProc, \"ThreadingModel\", \"Both\") ;\x0d\x0a\t}\x0d\x0a\x0d\x0a\t// Add the ProgID subkey under the CLSID key.\x0d\x0a\tsetKeyAndValue(szKey, \"ProgID\", szProgID) ;\x0d\x0a\x0d\x0a\t// A"; if (iIndex == index) return buffer; index++;
      buffer = "dd the version-independent ProgID subkey under CLSID key.\x0d\x0a\tsetKeyAndValue(szKey, \"VersionIndependentProgID\", szVerIndProgID) ;\x0d\x0a\x0d\x0a\t// Add the typelib\x0d\x0a\tsetKeyAndValue(szKey, \"TypeLib\", szLIBID) ;\x0d\x0a\x0d\x0a"; if (iIndex == index) return buffer; index++;
      buffer = "\x0d\x0a\t// Add the version-independent ProgID subkey under HKEY_CLASSES_ROOT.\x0d\x0a\tsetKeyAndValue(szVerIndProgID, NULL, szFriendlyName) ; \x0d\x0a\tsetKeyAndValue(szVerIndProgID, \"CLSID\", szCLSID) ;\x0d\x0a\tsetKeyAndValue"; if (iIndex == index) return buffer; index++;
      buffer = "(szVerIndProgID, \"CurVer\", szProgID) ;\x0d\x0a\x0d\x0a\t// Add the versioned ProgID subkey under HKEY_CLASSES_ROOT.\x0d\x0a\tsetKeyAndValue(szProgID, NULL, szFriendlyName) ; \x0d\x0a\tsetKeyAndValue(szProgID, \"CLSID\", szCLSID) "; if (iIndex == index) return buffer; index++;
      buffer = ";\x0d\x0a\x0d\x0a\t// add TypeLib keys\x0d\x0a\tstrcpy(szKey, \"TypeLib\\\\\") ;\x0d\x0a\tstrcat(szKey, szLIBID) ;\x0d\x0a\x0d\x0a\t// Add the CLSID to the registry.\x0d\x0a\tsetKeyAndValue(szKey, NULL, NULL) ;\x0d\x0a\tstrcat(szKey, \"\\\\1.0\");\x0d\x0a\tsetKeyAndVal"; if (iIndex == index) return buffer; index++;
      buffer = "ue(szKey, NULL, szFriendlyName) ;\x0d\x0a\tstrcat(szKey, \"\\\\0\");\x0d\x0a\tsetKeyAndValue(szKey, NULL, NULL) ;\x0d\x0a\tstrcat(szKey, \"\\\\win32\");\x0d\x0a\tsetKeyAndValue(szKey, NULL, szModule) ;\x0d\x0a\x0d\x0a\x0d\x0a\treturn S_OK ;\x0d\012}\x0d\x0a\x0d\x0a\x0d\012void R"; if (iIndex == index) return buffer; index++;
      buffer = "egisterInterface(HMODULE hModule,            // DLL module handle\x0d\012                       const CLSID& clsid,         // Class ID\x0d\012                       const char* szFriendlyName, // Friendly Name\x0d\x0a"; if (iIndex == index) return buffer; index++;
      buffer = "\t\t\t\t\t             const CLSID &libid,\x0d\x0a\t\t\t\t\t             const IID &iid)\x0d\012{\x0d\x0a\t// Get server location.\x0d\x0a\tchar szModule[512] ;\x0d\x0a\tDWORD dwResult =\x0d\x0a\t\t::GetModuleFileName(hModule, \x0d\x0a\t\t                    "; if (iIndex == index) return buffer; index++;
      buffer = "szModule,\x0d\x0a\t\t                    sizeof(szModule)/sizeof(char)) ;\x0d\x0a\tassert(dwResult != 0) ;\x0d\x0a\x0d\x0a\t// Convert the CLSID into a char.\x0d\x0a\tchar szCLSID[CLSID_STRING_SIZE] ;\x0d\x0a\tCLSIDtochar(clsid, szCLSID, size"; if (iIndex == index) return buffer; index++;
      buffer = "of(szCLSID)) ;\x0d\x0a\tchar szLIBID[CLSID_STRING_SIZE] ;\x0d\x0a\tCLSIDtochar(libid, szLIBID, sizeof(szCLSID)) ;\x0d\x0a\tchar szIID[CLSID_STRING_SIZE] ;\x0d\x0a\tCLSIDtochar(iid, szIID, sizeof(szCLSID)) ;\x0d\x0a\x0d\x0a\t// Build the key "; if (iIndex == index) return buffer; index++;
      buffer = "Interface\\\\{...}\x0d\x0a\tchar szKey[64] ;\x0d\x0a\tstrcpy(szKey, \"Interface\\\\\") ;\x0d\x0a\tstrcat(szKey, szIID) ;\x0d\012  \x0d\x0a\t// Add the value to the registry.\x0d\x0a\tsetKeyAndValue(szKey, NULL, szFriendlyName) ;\x0d\x0a\x0d\x0a\tchar szKey2[MA"; if (iIndex == index) return buffer; index++;
      buffer = "X_PATH];\x0d\x0a\tstrcpy(szKey2, szKey);\x0d\x0a\tstrcat(szKey2, \"\\\\ProxyStubClsID\");\x0d\x0a\t// Add the server filename subkey under the IID key.\x0d\x0a\tsetKeyAndValue(szKey2, NULL, \"{00020424-0000-0000-C000-000000000046}\");"; if (iIndex == index) return buffer; index++;
      buffer = " //IUnknown\x0d\x0a\x0d\x0a\tstrcpy(szKey2, szKey);\x0d\x0a\tstrcat(szKey2, \"\\\\ProxyStubClsID32\");\x0d\x0a\t// Add the server filename subkey under the IID key.\x0d\x0a\tsetKeyAndValue(szKey2, NULL, \"{00020424-0000-0000-C000-000000000"; if (iIndex == index) return buffer; index++;
      buffer = "046}\"); //IUnknown\x0d\x0a\x0d\x0a\tstrcpy(szKey2, szKey);\x0d\x0a\tstrcat(szKey2, \"\\\\TypeLib\");\x0d\x0a\t// Add the server filename subkey under the CLSID key.\x0d\x0a\tsetKeyAndValue(szKey2, NULL, szLIBID) ;\x0d\x0a\t\x0d\x0a\tsetValue(szKey2, \"V"; if (iIndex == index) return buffer; index++;
      buffer = "ersion\", \"1.0\") ;\x0d\012}\x0d\x0a\x0d\012void UnregisterInterface(const IID &iid)\x0d\012{\x0d\x0a\tchar szIID[CLSID_STRING_SIZE] ;\x0d\x0a\tCLSIDtochar(iid, szIID, sizeof(szIID)) ;\x0d\x0a\x0d\x0a\t// Build the key Interface\\\\{...}\x0d\x0a\tchar szKey[64] "; if (iIndex == index) return buffer; index++;
      buffer = ";\x0d\x0a\tstrcpy(szKey, \"Interface\\\\\") ;\x0d\x0a\tstrcat(szKey, szIID) ;\x0d\x0a\x0d\x0a\tLONG lResult = recursiveDeleteKey(HKEY_CLASSES_ROOT, szKey) ;\x0d\012}\x0d\x0a\x0d\012//\x0d\012// Remove the component from the registry.\x0d\012//\x0d\012LONG UnregisterS"; if (iIndex == index) return buffer; index++;
      buffer = "erver(const CLSID& clsid,         // Class ID\x0d\012                      const char* szVerIndProgID, // Programmatic\x0d\012                      const char* szProgID,\x0d\x0a\t\t\t\t\t            const CLSID &libid)     "; if (iIndex == index) return buffer; index++;
      buffer = "    // Type lib ID\x0d\012{\x0d\x0a\t// Convert the CLSID into a char.\x0d\x0a\tchar szCLSID[CLSID_STRING_SIZE] ;\x0d\x0a\tCLSIDtochar(clsid, szCLSID, sizeof(szCLSID)) ;\x0d\x0a\x0d\x0a\t// Build the key CLSID\\\\{...}\x0d\x0a\tchar szKey[64] ;\x0d\x0a\tst"; if (iIndex == index) return buffer; index++;
      buffer = "rcpy(szKey, \"CLSID\\\\\") ;\x0d\x0a\tstrcat(szKey, szCLSID) ;\x0d\x0a\x0d\x0a\t// Delete the CLSID Key - CLSID\\{...}\x0d\x0a\tLONG lResult = recursiveDeleteKey(HKEY_CLASSES_ROOT, szKey) ;\x0d\x0a\tassert((lResult == ERROR_SUCCESS) ||\x0d\x0a\t "; if (iIndex == index) return buffer; index++;
      buffer = "      (lResult == ERROR_FILE_NOT_FOUND)) ; // Subkey may not exist.\x0d\x0a\x0d\x0a\t// Delete the version-independent ProgID Key.\x0d\x0a\tlResult = recursiveDeleteKey(HKEY_CLASSES_ROOT, szVerIndProgID) ;\x0d\x0a\tassert((lRes"; if (iIndex == index) return buffer; index++;
      buffer = "ult == ERROR_SUCCESS) ||\x0d\x0a\t       (lResult == ERROR_FILE_NOT_FOUND)) ; // Subkey may not exist.\x0d\x0a\x0d\x0a\t// Delete the ProgID key.\x0d\x0a\tlResult = recursiveDeleteKey(HKEY_CLASSES_ROOT, szProgID) ;\x0d\x0a\tassert((lR"; if (iIndex == index) return buffer; index++;
      buffer = "esult == ERROR_SUCCESS) ||\x0d\x0a\t       (lResult == ERROR_FILE_NOT_FOUND)) ; // Subkey may not exist.\x0d\x0a\x0d\x0a\tchar szLIBID[CLSID_STRING_SIZE] ;\x0d\x0a\tCLSIDtochar(libid, szLIBID, sizeof(szLIBID)) ;\x0d\x0a\t\x0d\x0a\tstrcpy(szK"; if (iIndex == index) return buffer; index++;
      buffer = "ey, \"TypeLib\\\\\") ;\x0d\x0a\tstrcat(szKey, szLIBID) ;\x0d\x0a\x0d\x0a\t// Delete the TypeLib Key - LIBID\\{...}\x0d\x0a\tlResult = recursiveDeleteKey(HKEY_CLASSES_ROOT, szKey) ;\x0d\x0a\tassert((lResult == ERROR_SUCCESS) ||\x0d\x0a\t       (lR"; if (iIndex == index) return buffer; index++;
      buffer = "esult == ERROR_FILE_NOT_FOUND)) ; // Subkey may not exist.\x0d\x0a\x0d\x0a\treturn S_OK ;\x0d\012}\x0d\x0a\x0d\012///////////////////////////////////////////////////////////\x0d\012//\x0d\012// Internal helper functions\x0d\012//\x0d\x0a\x0d\012// Convert a CLS"; if (iIndex == index) return buffer; index++;
      buffer = "ID to a char string.\x0d\012void CLSIDtochar(const CLSID& clsid,\x0d\012                 char* szCLSID,\x0d\012                 int length)\x0d\012{\x0d\x0a\tassert(length >= CLSID_STRING_SIZE) ;\x0d\x0a\t// Get CLSID\x0d\x0a\tLPOLESTR wszCLSID "; if (iIndex == index) return buffer; index++;
      buffer = "= NULL ;\x0d\x0a\tHRESULT hr = StringFromCLSID(clsid, &wszCLSID) ;\x0d\x0a\tassert(SUCCEEDED(hr)) ;\x0d\x0a\x0d\x0a\t// Covert from wide characters to non-wide.\x0d\x0a\twcstombs(szCLSID, wszCLSID, length) ;\x0d\x0a\x0d\x0a\t// Free memory.\x0d\x0a\tCoTa"; if (iIndex == index) return buffer; index++;
      buffer = "skMemFree(wszCLSID) ;\x0d\012}\x0d\x0a\x0d\012//\x0d\012// Delete a key and all of its descendents.\x0d\012//\x0d\012LONG recursiveDeleteKey(HKEY hKeyParent,           // Parent of key to delete\x0d\012                        const char* lpsz"; if (iIndex == index) return buffer; index++;
      buffer = "KeyChild)  // Key to delete\x0d\012{\x0d\x0a\t// Open the child.\x0d\x0a\tHKEY hKeyChild ;\x0d\x0a\tLONG lRes = RegOpenKeyEx(hKeyParent, lpszKeyChild, 0,\x0d\x0a\t                         KEY_ALL_ACCESS, &hKeyChild) ;\x0d\x0a\tif (lRes != ER"; if (iIndex == index) return buffer; index++;
      buffer = "ROR_SUCCESS)\x0d\x0a\t{\x0d\x0a\t\treturn lRes ;\x0d\x0a\t}\x0d\x0a\x0d\x0a\t// Enumerate all of the decendents of this child.\x0d\x0a\tFILETIME time ;\x0d\x0a\tchar szBuffer[256] ;\x0d\x0a\tDWORD dwSize = 256 ;\x0d\x0a\twhile (RegEnumKeyEx(hKeyChild, 0, szBuffer"; if (iIndex == index) return buffer; index++;
      buffer = ", &dwSize, NULL,\x0d\x0a\t                    NULL, NULL, &time) == S_OK)\x0d\x0a\t{\x0d\x0a\t\t// Delete the decendents of this child.\x0d\x0a\t\tlRes = recursiveDeleteKey(hKeyChild, szBuffer) ;\x0d\x0a\t\tif (lRes != ERROR_SUCCESS)\x0d\x0a\t\t{"; if (iIndex == index) return buffer; index++;
      buffer = "\x0d\x0a\t\t\t// Cleanup before exiting.\x0d\x0a\t\t\tRegCloseKey(hKeyChild) ;\x0d\x0a\t\t\treturn lRes;\x0d\x0a\t\t}\x0d\x0a\t\tdwSize = 256 ;\x0d\x0a\t}\x0d\x0a\x0d\x0a\t// Close the child.\x0d\x0a\tRegCloseKey(hKeyChild) ;\x0d\x0a\x0d\x0a\t// Delete this child.\x0d\x0a\treturn RegDelete"; if (iIndex == index) return buffer; index++;
      buffer = "Key(hKeyParent, lpszKeyChild) ;\x0d\012}\x0d\x0a\x0d\012//\x0d\012// Create a key and set its value.\x0d\012//   - This helper function was borrowed and modifed from\x0d\012//     Kraig Brockschmidt's book Inside OLE.\x0d\012//\x0d\012BOOL setKeyAn"; if (iIndex == index) return buffer; index++;
      buffer = "dValue(const char* szKey,\x0d\012                    const char* szSubkey,\x0d\012                    const char* szValue)\x0d\012{\x0d\x0a\tHKEY hKey;\x0d\x0a\tchar szKeyBuf[1024] ;\x0d\x0a\x0d\x0a\t// Copy keyname into buffer.\x0d\x0a\tstrcpy(szKeyBu"; if (iIndex == index) return buffer; index++;
      buffer = "f, szKey) ;\x0d\x0a\x0d\x0a\t// Add subkey name to buffer.\x0d\x0a\tif (szSubkey != NULL)\x0d\x0a\t{\x0d\x0a\t\tstrcat(szKeyBuf, \"\\\\\") ;\x0d\x0a\t\tstrcat(szKeyBuf, szSubkey ) ;\x0d\x0a\t}\x0d\x0a\x0d\x0a\t// Create and open key and subkey.\x0d\x0a\tlong lResult = RegCr"; if (iIndex == index) return buffer; index++;
      buffer = "eateKeyEx(HKEY_CLASSES_ROOT ,\x0d\x0a\t                              szKeyBuf, \x0d\x0a\t                              0, NULL, REG_OPTION_NON_VOLATILE,\x0d\x0a\t                              KEY_ALL_ACCESS, NULL, \x0d\x0a\t    "; if (iIndex == index) return buffer; index++;
      buffer = "                          &hKey, NULL) ;\x0d\x0a\tif (lResult != ERROR_SUCCESS)\x0d\x0a\t{\x0d\x0a\t\treturn FALSE ;\x0d\x0a\t}\x0d\x0a\x0d\x0a\t// Set the Value.\x0d\x0a\tif (szValue != NULL)\x0d\x0a\t{\x0d\x0a\t\tRegSetValueEx(hKey, NULL, 0, REG_SZ, \x0d\x0a\t\t        "; if (iIndex == index) return buffer; index++;
      buffer = "      (BYTE *)szValue, \x0d\x0a\t\t              DWORD( 1+strlen(szValue) ) \x0d\x0a\t\t) ;\x0d\x0a\t}\x0d\x0a\x0d\x0a\tRegCloseKey(hKey) ;\x0d\x0a\treturn TRUE ;\x0d\012}\x0d\x0a\x0d\x0a\x0d\012BOOL setValue(const char* szKey,\x0d\012              const char* szEntry,\x0d\012  "; if (iIndex == index) return buffer; index++;
      buffer = "            const char* szValue)\x0d\012{\x0d\x0a\tHKEY hKey;\x0d\x0a\x0d\x0a\t// Create and open key and subkey.\x0d\x0a\tlong lResult = RegOpenKeyEx(HKEY_CLASSES_ROOT ,\x0d\x0a\t                              szKey, \x0d\x0a\t                    "; if (iIndex == index) return buffer; index++;
      buffer = "          0, \x0d\x0a\t                              KEY_ALL_ACCESS, \x0d\x0a\t\t\t\t\t\t\t\t  &hKey) ;\x0d\x0a\tif (lResult != ERROR_SUCCESS)\x0d\x0a\t{\x0d\x0a\t\treturn FALSE ;\x0d\x0a\t}\x0d\x0a\x0d\x0a\t// Set the Value.\x0d\x0a\tif (szValue != NULL)\x0d\x0a\t{\x0d\x0a\t\tRegSetV"; if (iIndex == index) return buffer; index++;
      buffer = "alueEx(hKey, szEntry, 0, REG_SZ, \x0d\x0a\t\t              (BYTE *)szValue, \x0d\x0a\t\t              DWORD( 1+strlen(szValue) )\x0d\x0a\t\t) ;\x0d\x0a\t}\x0d\x0a\x0d\x0a\tRegCloseKey(hKey) ;\x0d\x0a\x0d\x0a\treturn TRUE;\x0d\012}\x0d\x0a\x0d\x0a\x0d\x0a\x0d\012/////////////////////////"; if (iIndex == index) return buffer; index++;
      buffer = "////////////////////////////////////////////////////\x0d\012// TypeLib registration\x0d\x0a\x0d\012HRESULT LoadTypeLib(HINSTANCE hInstTypeLib, LPCOLESTR lpszIndex, BSTR* pbstrPath, ITypeLib** ppTypeLib)\x0d\012{\x0d\x0a\tATLASSERT("; if (iIndex == index) return buffer; index++;
      buffer = "pbstrPath != NULL && ppTypeLib != NULL);\x0d\x0a\tif (pbstrPath == NULL || ppTypeLib == NULL)\x0d\x0a\t\treturn E_POINTER;\x0d\x0a\x0d\x0a\t*pbstrPath = NULL;\x0d\x0a\t*ppTypeLib = NULL;\x0d\x0a\x0d\x0a\tUSES_CONVERSION;\x0d\x0a\tATLASSERT(hInstTypeLib !="; if (iIndex == index) return buffer; index++;
      buffer = " NULL);\x0d\x0a\tTCHAR szModule[MAX_PATH+10];\x0d\x0a\x0d\x0a\tDWORD dwFLen = ::GetModuleFileName(hInstTypeLib, szModule, MAX_PATH);\x0d\x0a\tif( dwFLen == 0 )\x0d\x0a\t\treturn HRESULT_FROM_WIN32(::GetLastError());\x0d\x0a\telse if( dwFLen ="; if (iIndex == index) return buffer; index++;
      buffer = "= MAX_PATH )\x0d\x0a\t\treturn HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);\x0d\x0a\x0d\x0a\t// get the extension pointer in case of fail\x0d\x0a\tLPTSTR lpszExt = NULL;\x0d\x0a\x0d\x0a\tlpszExt = ::PathFindExtension(szModule);\x0d\x0a\x0d\x0a\tif (lps"; if (iIndex == index) return buffer; index++;
      buffer = "zIndex != NULL)\x0d\x0a\t\tlstrcat(szModule, OLE2CT(lpszIndex));\x0d\x0a\tLPOLESTR lpszModule = T2OLE(szModule);\x0d\x0a\tHRESULT hr = ::LoadTypeLib(lpszModule, ppTypeLib);\x0d\x0a\tif (!SUCCEEDED(hr))\x0d\x0a\t{\x0d\x0a\t\t// typelib not in mo"; if (iIndex == index) return buffer; index++;
      buffer = "dule, try <module>.tlb instead\x0d\x0a\t\tlstrcpy(lpszExt, _T(\".tlb\"));\x0d\x0a\t\tlpszModule = T2OLE(szModule);\x0d\x0a\t\thr = ::LoadTypeLib(lpszModule, ppTypeLib);\x0d\x0a\t}\x0d\x0a\tif (SUCCEEDED(hr))\x0d\x0a\t{\x0d\x0a\t\t*pbstrPath = ::SysAllocSt"; if (iIndex == index) return buffer; index++;
      buffer = "ring(lpszModule);\x0d\x0a\t\tif (*pbstrPath == NULL)\x0d\x0a\t\t\thr = E_OUTOFMEMORY;\x0d\x0a\t}\x0d\x0a\treturn hr;\x0d\012}\x0d\x0a\x0d\012static inline UINT WINAPI GetDirLen(LPCOLESTR lpszPathName) throw()\x0d\012{\x0d\x0a\tATLASSERT(lpszPathName != NULL);\x0d\x0a\x0d"; if (iIndex == index) return buffer; index++;
      buffer = "\x0a\t// always capture the complete file name including extension (if present)\x0d\x0a\tLPCOLESTR lpszTemp = lpszPathName;\x0d\x0a\tfor (LPCOLESTR lpsz = lpszPathName; *lpsz != NULL; )\x0d\x0a\t{\x0d\x0a\t\tLPCOLESTR lp = CharNextO("; if (iIndex == index) return buffer; index++;
      buffer = "lpsz);\x0d\x0a\t\t// remember last directory/drive separator\x0d\x0a\t\tif (*lpsz == OLESTR('\\\\') || *lpsz == OLESTR('/') || *lpsz == OLESTR(':'))\x0d\x0a\t\t\tlpszTemp = lp;\x0d\x0a\t\tlpsz = lp;\x0d\x0a\t}\x0d\x0a\x0d\x0a\treturn UINT( lpszTemp-lpszPa"; if (iIndex == index) return buffer; index++;
      buffer = "thName );\x0d\012}\x0d\x0a\x0d\x0a\x0d\012HRESULT RegisterTypeLib(HINSTANCE hInstTypeLib, LPCOLESTR lpszIndex)\x0d\012{\x0d\x0a\tCComBSTR bstrPath;\x0d\x0a\tCComPtr<ITypeLib> pTypeLib;\x0d\x0a\tHRESULT hr = LoadTypeLib(hInstTypeLib, lpszIndex, &bstrPa"; if (iIndex == index) return buffer; index++;
      buffer = "th, &pTypeLib);\x0d\x0a\tif (SUCCEEDED(hr))\x0d\x0a\t{\x0d\x0a\t\tOLECHAR szDir[MAX_PATH];\x0d\x0a\t\tocscpy(szDir, bstrPath);\x0d\x0a\t\t// If index is specified remove it from the path\x0d\x0a\t\tif (lpszIndex != NULL)\x0d\x0a\t\t{\x0d\x0a\t\t\tsize_t nLenPath "; if (iIndex == index) return buffer; index++;
      buffer = "= ocslen(szDir);\x0d\x0a\t\t\tsize_t nLenIndex = ocslen(lpszIndex);\x0d\x0a\t\t\tif (memcmp(szDir + nLenPath - nLenIndex, lpszIndex, nLenIndex) == 0)\x0d\x0a\t\t\t\tszDir[nLenPath - nLenIndex] = 0;\x0d\x0a\t\t}\x0d\x0a\t\tszDir[GetDirLen(szDir)"; if (iIndex == index) return buffer; index++;
      buffer = "] = 0;\x0d\x0a\t\thr = ::RegisterTypeLib(pTypeLib, bstrPath, szDir);\x0d\x0a\t}\x0d\x0a\treturn hr;\x0d\012}\x0d\x0a\x0d\012HRESULT UnRegisterTypeLib(HINSTANCE hInstTypeLib, LPCOLESTR lpszIndex)\x0d\012{\x0d\x0a\tCComBSTR bstrPath;\x0d\x0a\tCComPtr<ITypeLib> p"; if (iIndex == index) return buffer; index++;
      buffer = "TypeLib;\x0d\x0a\tHRESULT hr = LoadTypeLib(hInstTypeLib, lpszIndex, &bstrPath, &pTypeLib);\x0d\x0a\tif (SUCCEEDED(hr))\x0d\x0a\t{\x0d\x0a\t\tTLIBATTR* ptla;\x0d\x0a\t\thr = pTypeLib->GetLibAttr(&ptla);\x0d\x0a\t\tif (SUCCEEDED(hr))\x0d\x0a\t\t{\x0d\x0a\t\t\thr ="; if (iIndex == index) return buffer; index++;
      buffer = " ::UnRegisterTypeLib(ptla->guid, ptla->wMajorVerNum, ptla->wMinorVerNum, ptla->lcid, ptla->syskind);\x0d\x0a\t\t\tpTypeLib->ReleaseTLibAttr(ptla);\x0d\x0a\t\t}\x0d\x0a\t}\x0d\x0a\treturn hr;\x0d\012}\x0d\x0a\x0d\012char *rstrstr(char * _Str, char * "; if (iIndex == index) return buffer; index++;
      buffer = "_SubStr)\x0d\012{\x0d\012  size_t  s1len = strlen(_Str);\x0d\012  size_t  s2len = strlen(_SubStr);\x0d\012  char *s;\x0d\x0a\x0d\012  if (s2len > s1len)\x0d\012    return NULL;\x0d\012  for (s = _Str + s1len - s2len; s >= _Str; --s)\x0d\012    if (strncm"; if (iIndex == index) return buffer; index++;
      buffer = "p(s, _SubStr, s2len) == 0)\x0d\012      return s;\x0d\012  return NULL;\x0d\012}\x0d\x0a\x0d\012HRESULT RegisterServer(HMODULE hModule,\x0d\012                       const char* szAppID,\x0d\012                       const CLSID& clsid,\x0d\012    "; if (iIndex == index) return buffer; index++;
      buffer = "                   const char* szFriendlyName,\x0d\012                       const char* szVerIndProgID,\x0d\012                       const char* szProgID,\x0d\x0a\t\t\t\t\t             const CLSID& libid)\x0d\012{\x0d\012  // Get ser"; if (iIndex == index) return buffer; index++;
      buffer = "ver location.\x0d\012  char szModule[1024];\x0d\012  DWORD dwResult =\x0d\x0a\t  ::GetModuleFileName(hModule, \x0d\x0a\t\t                    szModule,\x0d\x0a\t\t                    sizeof(szModule)/sizeof(char)) ;\x0d\012  assert(dwResult "; if (iIndex == index) return buffer; index++;
      buffer = "!= 0) ;\x0d\012  long nModuleLength = strlen(szModule);\x0d\x0a\x0d\012  // Get server filename\x0d\012  char * szModuleFilename = rstrstr(szModule, \"\\\\\");\x0d\012  assert(szModuleFilename != 0) ;\x0d\012  szModuleFilename++; //skip \\ c"; if (iIndex == index) return buffer; index++;
      buffer = "haracter\x0d\012  long nFilenameLength = strlen(szModuleFilename);\x0d\x0a\x0d\012  // Get server filename extension\x0d\012  char * szExtension = rstrstr(szModule, \".\");\x0d\012  assert(szExtension != 0) ;\x0d\012  long nExtensionLengt"; if (iIndex == index) return buffer; index++;
      buffer = "h = strlen(szExtension);\x0d\x0a\x0d\012  // Get server filename (without extension)\x0d\012  char szModuleFilenameOnly[64];\x0d\012  strncpy(szModuleFilenameOnly, szModuleFilename, nFilenameLength-nExtensionLength);\x0d\012  szMo"; if (iIndex == index) return buffer; index++;
      buffer = "duleFilenameOnly[nFilenameLength-nExtensionLength] = 0;\x0d\x0a\x0d\012  // Build the key AppID\\\\{filename.exe}\x0d\012  char szKey[64] ;\x0d\012  strcpy(szKey, \"AppID\\\\\") ;\x0d\012  strcat(szKey, szModuleFilename) ;\x0d\012  \x0d\012  // Add"; if (iIndex == index) return buffer; index++;
      buffer = " the AppID to the registry.\x0d\012  setKeyAndValue(szKey, NULL, NULL) ;\x0d\012  setValue(szKey, \"AppID\", szAppID) ;\x0d\x0a\x0d\012  // Build the key AppID\\\\{GUID}\x0d\012  strcpy(szKey, \"AppID\\\\\") ;\x0d\012  strcat(szKey, szAppID) ;\x0d"; if (iIndex == index) return buffer; index++;
      buffer = "\012  \x0d\012  // Add the AppID to the registry.\x0d\012  setKeyAndValue(szKey, NULL, szModuleFilenameOnly) ;\x0d\x0a\x0d\012  HRESULT hr = RegisterServer(hModule, clsid, szFriendlyName, szVerIndProgID, szProgID, libid);\x0d\012  re"; if (iIndex == index) return buffer; index++;
      buffer = "turn hr;\x0d\012}\x0d\x0a\x0d\012HRESULT UnregisterServer(HMODULE hModule,\x0d\012                         const char* szAppID,\x0d\012                         const CLSID& clsid,\x0d\012                         const char* szVerIndProg"; if (iIndex == index) return buffer; index++;
      buffer = "ID,\x0d\012                         const char* szProgID,\x0d\x0a\t\t\t\t\t\t             const CLSID& libid)\x0d\012{\x0d\012  // Get server location.\x0d\012  char szModule[1024];\x0d\012  DWORD dwResult =\x0d\x0a\t  ::GetModuleFileName(hModule, \x0d"; if (iIndex == index) return buffer; index++;
      buffer = "\x0a\t\t                    szModule,\x0d\x0a\t\t                    sizeof(szModule)/sizeof(char)) ;\x0d\012  assert(dwResult != 0) ;\x0d\012  long nModuleLength = strlen(szModule);\x0d\x0a\x0d\012  // Get server filename\x0d\012  char * szMo"; if (iIndex == index) return buffer; index++;
      buffer = "duleFilename = rstrstr(szModule, \"\\\\\");\x0d\012  assert(szModuleFilename != 0) ;\x0d\012  szModuleFilename++; //skip \\ character\x0d\012  long nFilenameLength = strlen(szModuleFilename);\x0d\x0a\x0d\012  // Get server filename ext"; if (iIndex == index) return buffer; index++;
      buffer = "ension\x0d\012  char * szExtension = rstrstr(szModule, \".\");\x0d\012  assert(szExtension != 0) ;\x0d\012  long nExtensionLength = strlen(szExtension);\x0d\x0a\x0d\012  // Build the key AppID\\\\{filename.exe}\x0d\012  char szKey[64] ;\x0d\012  "; if (iIndex == index) return buffer; index++;
      buffer = "strcpy(szKey, \"AppID\\\\\") ;\x0d\012  strcat(szKey, szModuleFilename) ;\x0d\012  \x0d\012  // Delete the AppID Key - AppID\\{filename.exe}\x0d\012  LONG lResult = recursiveDeleteKey(HKEY_CLASSES_ROOT, szKey) ;\x0d\012  assert((lResul"; if (iIndex == index) return buffer; index++;
      buffer = "t == ERROR_SUCCESS) ||\x0d\x0a\t       (lResult == ERROR_FILE_NOT_FOUND)) ; // Subkey may not exist.\x0d\x0a\x0d\012  // Build the key AppID\\\\{GUID}\x0d\012  strcpy(szKey, \"AppID\\\\\") ;\x0d\012  strcat(szKey, szAppID) ;\x0d\012  \x0d\012  // De"; if (iIndex == index) return buffer; index++;
      buffer = "lete the AppID Key - AppID\\{GUID}\x0d\012  lResult = recursiveDeleteKey(HKEY_CLASSES_ROOT, szKey) ;\x0d\012  assert((lResult == ERROR_SUCCESS) ||\x0d\x0a\t       (lResult == ERROR_FILE_NOT_FOUND)) ; // Subkey may not ex"; if (iIndex == index) return buffer; index++;
      oLength = 99;
      buffer = "ist.\x0d\x0a\x0d\012  HRESULT hr = UnregisterServer(clsid, szVerIndProgID, szProgID, libid);\x0d\012  return hr;\x0d\012}\x0d\x0a"; if (iIndex == index) return buffer; index++;
      oLength = 0;
      return NULL;
    }
    virtual const char * getMd5() { return "b29c786b2b09d6e944bcd837fc4aacbe"; }
    virtual char * newBuffer()
    {
      size_t size = getSize();
      char * buffer = new char[size];
      if (buffer == NULL)
        return NULL;
      size_t numSegments = getNumSegments();
      size_t segmentLength = 0;
      size_t index = 0;
      for(size_t i=0; i<numSegments; i++)
      {
        const char * segmentBuffer = getSegment(i, segmentLength);
        memcpy(&buffer[index], segmentBuffer, segmentLength);
        index += segmentLength;
      }
      return buffer;
    }
    virtual bool save(const char * iFilename)
    {
      FILE * f = fopen(iFilename, "wb");
      if (!f) return false;
      size_t numSegments = getNumSegments();
      size_t segmentLength = 0;
      const char * buffer = NULL;
      for(size_t i=0; i<numSegments; i++)
      {
        buffer = getSegment(i, segmentLength);
        fwrite(buffer, 1, segmentLength, f);
      }
      fclose(f);
      return true;
    }
  };
  File & getRegistryCppFile() { static RegistryCppFile _instance; return _instance; }
}; //bin2cpp
