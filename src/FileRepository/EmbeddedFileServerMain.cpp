/**
 * This file was generated by
 * bin2cpp v1.3.
 * Copyright (C) 2013-2014 end2endzone.com. All rights reserved.
 * Do not modify this file.
 */
#include ".\EmbeddedFileServerMain.h"
#include <stdio.h> //for FILE
#include <string> //for memcpy
namespace bin2cpp
{
  class ServerMainFile : public virtual bin2cpp::File
  {
  public:
    ServerMainFile() {}
    ~ServerMainFile() {}
    virtual size_t getSize() { return 2279; }
    virtual size_t getSegmentSize() { return 200; }
    virtual size_t getNumSegments() { return 12; }
    virtual const char * getFilename() { return "DCOMPLUGIN_COMPONENT_NAMEServerMain.cpp"; }
    virtual const char * getSegment(size_t iIndex, size_t & oLength)
    {
      oLength = 0;
      if (iIndex >= getNumSegments())
        return NULL;
      const char * buffer = NULL;
      size_t index = 0;
      oLength = getSegmentSize();
      buffer = "// DCOMPLUGIN_COMPONENT_NAMEServerMain.cpp : Defines the entry point for the application.\x0d\012//\x0d\x0a\x0d\012#define WIN32_LEAN_AND_MEAN    // Exclude rarely-used stuff from Windows headers\x0d\012#include <windows.h>\x0d"; if (iIndex == index) return buffer; index++;
      buffer = "\x0a\x0d\012#include <objbase.h> // \x0d\012#include \"DCOMPLUGIN_COMPONENT_NAMEServer_h.h\"\x0d\012#include \"DCOMPLUGIN_COMPONENT_NAMEServer.h\"\x0d\012#include <stdio.h>\x0d\x0a\x0d\012int APIENTRY WinMain(HINSTANCE hInstance,\x0d\012            "; if (iIndex == index) return buffer; index++;
      buffer = "         HINSTANCE hPrevInstance,\x0d\012                     LPSTR     lpCmdLine,\x0d\012                     int       nCmdShow)\x0d\012{\x0d\012  // register/unregister server on demand\x0d\012  //\x0d\012  char szUpperCommandLine[MA"; if (iIndex == index) return buffer; index++;
      buffer = "X_PATH];\x0d\012  strcpy (szUpperCommandLine, lpCmdLine); // copy command line and work with it.\x0d\012  _strupr (szUpperCommandLine);\x0d\x0a\x0d\012  //Detect silent flag\x0d\012  bool silent = false;\x0d\012  if (strstr(szUpperComma"; if (iIndex == index) return buffer; index++;
      buffer = "ndLine, \"-S\") || strstr(szUpperCommandLine, \"/S\"))\x0d\012  {\x0d\012    silent = true;\x0d\012  }\x0d\x0a\x0d\012  if (strstr (szUpperCommandLine, \"UNREGSERVER\"))\x0d\012  {\x0d\012    HRESULT hr = DllUnregisterServer();\x0d\012    if (SUCCEEDED(h"; if (iIndex == index) return buffer; index++;
      buffer = "r))\x0d\012    {\x0d\012      if (!silent)\x0d\012        MessageBox(NULL, \"Unregister completed\", \"Success\", MB_OK | MB_ICONINFORMATION);\x0d\012      return 0;\x0d\012    }\x0d\012    else\x0d\012    {\x0d\012      if (!silent)\x0d\012        MessageBo"; if (iIndex == index) return buffer; index++;
      buffer = "x(NULL, \"Unregister failed\", \"Error\", MB_OK | MB_ICONERROR);\x0d\012      return 1;\x0d\012    }\x0d\012  }\x0d\012  else if (strstr (szUpperCommandLine, \"REGSERVER\"))\x0d\012  {\x0d\012    HRESULT hr = DllRegisterServer();\x0d\012    if (SUC"; if (iIndex == index) return buffer; index++;
      buffer = "CEEDED(hr))\x0d\012    {\x0d\012      if (!silent)\x0d\012        MessageBox(NULL, \"Register completed\", \"Success\", MB_OK | MB_ICONINFORMATION);\x0d\012      return 0;\x0d\012    }\x0d\012    else\x0d\012    {\x0d\012      if (!silent)\x0d\012        Mes"; if (iIndex == index) return buffer; index++;
      buffer = "sageBox(NULL, \"Register failed\", \"Error\", MB_OK | MB_ICONERROR);\x0d\012      return 1;\x0d\012    }\x0d\012  }\x0d\x0a\x0d\012  // initialize the COM library\x0d\012  ::CoInitialize(NULL);\x0d\x0a\x0d\012  // register ourself as a class object aga"; if (iIndex == index) return buffer; index++;
      buffer = "inst the internal COM table\x0d\012  // (this has nothing to do with the registry)\x0d\012  DWORD nToken = CoEXEInitialize();\x0d\x0a\x0d\012  // -- the message pump ----------------\x0d\012  //\x0d\012  // (loop ends if WM_QUIT message"; if (iIndex == index) return buffer; index++;
      buffer = " is received)\x0d\012  //\x0d\012  MSG msg;\x0d\012  while (GetMessage(&msg, 0, 0, 0) > 0) \x0d\012  {\x0d\012    TranslateMessage(&msg);\x0d\012    DispatchMessage(&msg);\x0d\012  }\x0d\x0a\x0d\012  // unregister from the known table of class objects\x0d\012 "; if (iIndex == index) return buffer; index++;
      oLength = 79;
      buffer = " CoEXEUninitialize(nToken);\x0d\x0a\x0d\012  // \x0d\012  ::CoUninitialize();\x0d\x0a\x0d\012  return 0;\x0d\012}\x0d\x0a"; if (iIndex == index) return buffer; index++;
      oLength = 0;
      return NULL;
    }
    virtual const char * getMd5() { return "8ee42cd144f932a5028f8e670192a414"; }
    virtual char * newBuffer()
    {
      size_t size = getSize();
      char * buffer = new char[size];
      if (buffer == NULL)
        return NULL;
      size_t numSegments = getNumSegments();
      size_t segmentLength = 0;
      size_t index = 0;
      for(size_t i=0; i<numSegments; i++)
      {
        const char * segmentBuffer = getSegment(i, segmentLength);
        memcpy(&buffer[index], segmentBuffer, segmentLength);
        index += segmentLength;
      }
      return buffer;
    }
    virtual bool save(const char * iFilename)
    {
      FILE * f = fopen(iFilename, "wb");
      if (!f) return false;
      size_t numSegments = getNumSegments();
      size_t segmentLength = 0;
      const char * buffer = NULL;
      for(size_t i=0; i<numSegments; i++)
      {
        buffer = getSegment(i, segmentLength);
        fwrite(buffer, 1, segmentLength, f);
      }
      fclose(f);
      return true;
    }
  };
  File & getServerMainFile() { static ServerMainFile _instance; return _instance; }
}; //bin2cpp
