/**
 * This file was generated by
 * bin2cpp v1.3.
 * Copyright (C) 2013-2014 end2endzone.com. All rights reserved.
 * Do not modify this file.
 */
#include ".\EmbeddedFileMessageSerializerCpp.h"
#include <stdio.h> //for FILE
#include <string> //for memcpy
namespace bin2cpp
{
  class MessageSerializerCppFile : public virtual bin2cpp::File
  {
  public:
    MessageSerializerCppFile() {}
    ~MessageSerializerCppFile() {}
    virtual size_t getSize() { return 6204; }
    virtual size_t getSegmentSize() { return 200; }
    virtual size_t getNumSegments() { return 32; }
    virtual const char * getFilename() { return "MessageSerializer.cpp"; }
    virtual const char * getSegment(size_t iIndex, size_t & oLength)
    {
      oLength = 0;
      if (iIndex >= getNumSegments())
        return NULL;
      const char * buffer = NULL;
      size_t index = 0;
      oLength = getSegmentSize();
      buffer = "#include \"MessageSerializer.h\"\x0d\x0a\x0d\012#include <vector>\x0d\x0a\x0d\012namespace DCOMPLUGIN_PACKAGE_NAME {\x0d\x0a\x0d\012HRESULT Variant2ByteArray(VARIANT & iVar, DCOMPLUGIN_PACKAGE_NAME::VariantFlavor & oVariantFlavor, std::st"; if (iIndex == index) return buffer; index++;
      buffer = "ring & oData)\x0d\012{\x0d\012  static const VARTYPE IS_VARIANT       = (VT_BYREF | VT_VARIANT);\x0d\012  static const VARTYPE BYTE_ARRAY       = (VT_ARRAY | VT_UI1);\x0d\012  static const VARTYPE VARIANT_ARRAY    = (VT_ARRA"; if (iIndex == index) return buffer; index++;
      buffer = "Y | VT_VARIANT);\x0d\x0a\x0d\012  //Note that c++ serialize a \"byte array\" as a \"SAFEARRAY of bytes inside a VARIANT\". This structure \x0d\012  //store the bytes data in a consecutive buffer (all values are one after t"; if (iIndex == index) return buffer; index++;
      buffer = "he other) which makes the \x0d\012  //process of converting the data to a std::vector or std::string easy.\x0d\012  //However, weakly-typed languages (such as VBScript) does not serialize data the same way.\x0d\012  //"; if (iIndex == index) return buffer; index++;
      buffer = "VBScript serialize data as a VARIANT holding a SAFEARRAY of VARIANT, each VARIANT holding a single byte.\x0d\012  //To recover the data, one must read every VARIANT one by one and make sure it contains a by"; if (iIndex == index) return buffer; index++;
      buffer = "te before\x0d\012  //storing this byte within the output array.\x0d\x0a\x0d\012  if (iVar.vt == IS_VARIANT)\x0d\012  {\x0d\012    //this VARIANT contains another VARIANT\x0d\012    //it is expected that the inner VARIANT contains an ARR"; if (iIndex == index) return buffer; index++;
      buffer = "AY of VARIANT...\x0d\012    //this is typical of VBScript (weakly-typed languages)\x0d\012    VARIANT * v1 = iVar.pvarVal;\x0d\012    if (v1 == NULL)\x0d\012      return NULL;\x0d\x0a\x0d\012    HRESULT hr = Variant2ByteArray(*v1, oVari"; if (iIndex == index) return buffer; index++;
      buffer = "antFlavor, oData);\x0d\012    oVariantFlavor = VBSCRIPT;\x0d\012    return hr;\x0d\012  }\x0d\012  else if (iVar.vt == VARIANT_ARRAY)\x0d\012  {\x0d\012    //this variant contains an array of VARIANT\x0d\012    //this is typical of VBScript ("; if (iIndex == index) return buffer; index++;
      buffer = "weakly-typed languages)\x0d\012    SAFEARRAY * sa = iVar.parray;\x0d\x0a\x0d\012    VARIANT * values;\x0d\012    HRESULT hr = SafeArrayAccessData(sa, (void**)&values); // direct access to SA memory\x0d\012    if (FAILED(hr))\x0d\012    "; if (iIndex == index) return buffer; index++;
      buffer = "  return NULL;\x0d\x0a\x0d\012    // get array bounds\x0d\012    long lowerBound = 0;\x0d\012    long upperBound = 0;\x0d\012    SafeArrayGetLBound(sa, 1, &lowerBound);\x0d\012    SafeArrayGetUBound(sa, 1, &upperBound);\x0d\x0a\x0d\012    long numE"; if (iIndex == index) return buffer; index++;
      buffer = "lements = upperBound - lowerBound + 1;\x0d\012    if (numElements == 0)\x0d\012    {\x0d\012      oData.clear();\x0d\012    }\x0d\012    else\x0d\012    {\x0d\012      //copy each VARIANT element one by one\x0d\012      for(long i=0; i<numElements;"; if (iIndex == index) return buffer; index++;
      buffer = " i++)\x0d\012      {\x0d\012        VARIANT & var = values[i];\x0d\x0a\x0d\012        //does the VARIANT contains unsigned char data ?\x0d\012        if (var.vt == VT_UI1)\x0d\012        {\x0d\012          oData.append(1, var.bVal);\x0d\012        "; if (iIndex == index) return buffer; index++;
      buffer = "}\x0d\012      }\x0d\012    }\x0d\012    SafeArrayUnaccessData(sa);\x0d\x0a\x0d\012    oVariantFlavor = VBSCRIPT;\x0d\x0a\x0d\012    return S_OK;\x0d\012  }\x0d\012  else if (iVar.vt == BYTE_ARRAY)\x0d\012  {\x0d\012    //this VARIANT is a SAFEARRAY that contains By"; if (iIndex == index) return buffer; index++;
      buffer = "tes (unsigned char)\x0d\012    //this is typical of C++ client calls\x0d\012    SAFEARRAY * sa = iVar.parray;\x0d\x0a\x0d\012    byte * values;\x0d\012    HRESULT hr = SafeArrayAccessData(sa, (void**)&values); // direct access to "; if (iIndex == index) return buffer; index++;
      buffer = "SA memory\x0d\012    if (FAILED(hr))\x0d\012      return NULL;\x0d\x0a\x0d\012    // get array bounds\x0d\012    long lowerBound = 0;\x0d\012    long upperBound = 0;\x0d\012    SafeArrayGetLBound(sa, 1, &lowerBound);\x0d\012    SafeArrayGetUBound(s"; if (iIndex == index) return buffer; index++;
      buffer = "a, 1, &upperBound);\x0d\x0a\x0d\012    long numElements = upperBound - lowerBound + 1;\x0d\012    if (numElements == 0)\x0d\012    {\x0d\012      oData.clear();\x0d\012    }\x0d\012    else\x0d\012    {\x0d\012      //copy all continuous BYTE elements as"; if (iIndex == index) return buffer; index++;
      buffer = " a single operation\x0d\012      oData.assign( (const char*)values, numElements);\x0d\012    }\x0d\012    SafeArrayUnaccessData(sa);\x0d\012    \x0d\012    oVariantFlavor = CPLUSPLUS;\x0d\x0a\x0d\012    return S_OK;\x0d\012  }\x0d\012  else\x0d\012    return E"; if (iIndex == index) return buffer; index++;
      buffer = "_INVALIDARG;\x0d\012}\x0d\x0a\x0d\012HRESULT ByteArray2Variant(const std::string & iData, const DCOMPLUGIN_PACKAGE_NAME::VariantFlavor & iVariantFlavor, VARIANT & oVar)\x0d\012{\x0d\012  switch(iVariantFlavor)\x0d\012  {\x0d\012  case DCOMPLU"; if (iIndex == index) return buffer; index++;
      buffer = "GIN_PACKAGE_NAME::CPLUSPLUS:\x0d\012    {\x0d\012      //https://stackoverflow.com/questions/10905043/c-sharp-marshal-byte-to-com-safearray-parameter-with-ref-object-signature\x0d\012      VariantInit (&oVar);\x0d\012      V"; if (iIndex == index) return buffer; index++;
      buffer = "ariantClear(&oVar);\x0d\x0a\x0d\012      SAFEARRAYBOUND bounds[1];\x0d\012      bounds[0].cElements = iData.size();\x0d\012      bounds[0].lLbound = 1;\x0d\x0a\x0d\012      SAFEARRAY* sa = SafeArrayCreate(VT_UI1, 1, bounds);\x0d\012      if(s"; if (iIndex == index) return buffer; index++;
      buffer = "a == NULL)\x0d\012        return E_OUTOFMEMORY;\x0d\x0a\x0d\012      //copy data to SAFEARRAY\x0d\012      SafeArrayLock(sa);\x0d\012      memcpy(sa->pvData, iData.c_str(), iData.size());\x0d\012      SafeArrayUnlock(sa);\x0d\x0a\x0d\012      oVar."; if (iIndex == index) return buffer; index++;
      buffer = "parray = sa;\x0d\012      oVar.vt = VT_ARRAY | VT_UI1;\x0d\012      return S_OK;\x0d\012    };\x0d\012    break;\x0d\012  case DCOMPLUGIN_PACKAGE_NAME::VBSCRIPT:\x0d\012    {\x0d\012      //https://stackoverflow.com/questions/10905043/c-sharp"; if (iIndex == index) return buffer; index++;
      buffer = "-marshal-byte-to-com-safearray-parameter-with-ref-object-signature\x0d\012      VariantInit (&oVar);\x0d\012      VariantClear(&oVar);\x0d\x0a\x0d\012      SAFEARRAYBOUND bounds[1];\x0d\012      bounds[0].cElements = iData.size();"; if (iIndex == index) return buffer; index++;
      buffer = "\x0d\012      bounds[0].lLbound = 1;\x0d\x0a\x0d\012      SAFEARRAY* sa = SafeArrayCreate(VT_VARIANT, 1, bounds);\x0d\012      if(sa == NULL)\x0d\012        return E_OUTOFMEMORY;\x0d\x0a\x0d\012      //copy data to SAFEARRAY\x0d\012      VARIANT * "; if (iIndex == index) return buffer; index++;
      buffer = "values = NULL;\x0d\012      HRESULT hr = SafeArrayAccessData(sa, (void **)&values);\x0d\012      if (SUCCEEDED(hr))\x0d\012      {\x0d\012        for(size_t i=0; i<iData.size(); i++)\x0d\012        {\x0d\012          VARIANT & tmp = val"; if (iIndex == index) return buffer; index++;
      buffer = "ues[i];\x0d\012          VariantInit (&tmp);\x0d\012          tmp.vt = VT_UI1;\x0d\012          tmp.bVal = (unsigned char)iData[i];\x0d\012        }\x0d\012        SafeArrayUnaccessData(sa);\x0d\012      }\x0d\x0a\x0d\012      oVar.parray = sa;\x0d\012  "; if (iIndex == index) return buffer; index++;
      buffer = "    oVar.vt = VT_ARRAY | VT_VARIANT;\x0d\012      return S_OK;\x0d\012    };\x0d\012    break;\x0d\012  default:\x0d\012    return E_INVALIDARG;\x0d\012  };\x0d\x0a\x0d\012}\x0d\x0a\x0d\012///\x0d\012HRESULT SerializeMessageToVariant(const google::protobuf::MessageL"; if (iIndex == index) return buffer; index++;
      buffer = "ite & iMsg, const DCOMPLUGIN_PACKAGE_NAME::VariantFlavor & iVariantFlavor, VARIANT & oVar)\x0d\012{\x0d\012  std::string data;\x0d\012  bool success = iMsg.SerializeToString(&data);\x0d\012  if (!success)\x0d\012    return E_INVAL"; if (iIndex == index) return buffer; index++;
      buffer = "IDARG;\x0d\x0a\x0d\012  HRESULT hr = ByteArray2Variant(data, iVariantFlavor, oVar);\x0d\012  if (FAILED(hr))\x0d\012    return hr;\x0d\012  return S_OK;\x0d\012}\x0d\x0a\x0d\012///\x0d\012HRESULT DeserializeVariantToMessage(VARIANT & iVar, google::protob"; if (iIndex == index) return buffer; index++;
      buffer = "uf::MessageLite & oMsg, DCOMPLUGIN_PACKAGE_NAME::VariantFlavor & oVariantFlavor)\x0d\012{\x0d\012  std::string data;\x0d\012  HRESULT hr = Variant2ByteArray(iVar, oVariantFlavor, data);\x0d\012  if (FAILED(hr))\x0d\012    return h"; if (iIndex == index) return buffer; index++;
      buffer = "r;\x0d\x0a\x0d\012  //deserialize data into message\x0d\012  bool success = oMsg.ParseFromString(data);\x0d\012  if (!success)\x0d\012  {\x0d\012    return E_INVALIDARG;\x0d\012  }\x0d\x0a\x0d\012  return S_OK;\x0d\012}\x0d\x0a\x0d\012}  // namespace DCOMPLUGIN_PACKAGE_NA"; if (iIndex == index) return buffer; index++;
      oLength = 4;
      buffer = "ME\x0d\x0a"; if (iIndex == index) return buffer; index++;
      oLength = 0;
      return NULL;
    }
    virtual const char * getMd5() { return "b52ffd54212c331891f13f353f01f7fe"; }
    virtual char * newBuffer()
    {
      size_t size = getSize();
      char * buffer = new char[size];
      if (buffer == NULL)
        return NULL;
      size_t numSegments = getNumSegments();
      size_t segmentLength = 0;
      size_t index = 0;
      for(size_t i=0; i<numSegments; i++)
      {
        const char * segmentBuffer = getSegment(i, segmentLength);
        memcpy(&buffer[index], segmentBuffer, segmentLength);
        index += segmentLength;
      }
      return buffer;
    }
    virtual bool save(const char * iFilename)
    {
      FILE * f = fopen(iFilename, "wb");
      if (!f) return false;
      size_t numSegments = getNumSegments();
      size_t segmentLength = 0;
      const char * buffer = NULL;
      for(size_t i=0; i<numSegments; i++)
      {
        buffer = getSegment(i, segmentLength);
        fwrite(buffer, 1, segmentLength, f);
      }
      fclose(f);
      return true;
    }
  };
  File & getMessageSerializerCppFile() { static MessageSerializerCppFile _instance; return _instance; }
}; //bin2cpp
