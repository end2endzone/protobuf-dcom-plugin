/**
 * This file was generated by bin2cpp v2.2.0
 * Copyright (C) 2013-2019 end2endzone.com. All rights reserved.
 * bin2cpp is open source software, see http://github.com/end2endzone/bin2cpp
 * Source code for file 'DCOMPLUGIN_COMPONENT_NAMEServer.cpp', last modified 1552247129.
 * Do not modify this file.
 */
#include "EmbeddedFileServerCpp.h"
#include <stdio.h> //for FILE
#include <string> //for memcpy
namespace bin2cpp
{
  class ServerCppFile : public virtual bin2cpp::File
  {
  public:
    ServerCppFile() { build(); }
    virtual ~ServerCppFile() {}
    virtual size_t getSize() const { return 8987; }
    virtual const char * getFilename() const { return "DCOMPLUGIN_COMPONENT_NAMEServer.cpp"; }
    virtual const char * getBuffer() const { return mBuffer.c_str(); }
    void build()
    {
      mBuffer.clear();
      mBuffer.reserve(getSize()); //allocate all required memory at once to prevent reallocations
      mBuffer.append("#include <objbase.h>\r\n\r\n#ifdef CMAKE_INTDIR\r\n  #ifdef NDEBUG\r\n    #include \"DCOMPLUGIN_COMPONENT_NAMEServer.dir/Release/DCOMPLUGIN_COMPONENT_NAMEServer.h\"   // interface declaration\r\n    #include \"DCO", 200);
      mBuffer.append("MPLUGIN_COMPONENT_NAMEServer.dir/Release/DCOMPLUGIN_COMPONENT_NAMEServer_i.c\" // IID, CLSID\r\n  #else\r\n    #include \"DCOMPLUGIN_COMPONENT_NAMEServer.dir/Debug/DCOMPLUGIN_COMPONENT_NAMEServer.h\"   // in", 200);
      mBuffer.append("terface declaration\r\n    #include \"DCOMPLUGIN_COMPONENT_NAMEServer.dir/Debug/DCOMPLUGIN_COMPONENT_NAMEServer_i.c\" // IID, CLSID\r\n  #endif\r\n#else\r\n  #include \"DCOMPLUGIN_COMPONENT_NAMEServer_h.h\" // in", 200);
      mBuffer.append("terface declaration\r\n  #include \"DCOMPLUGIN_COMPONENT_NAMEServer_i.c\" // IID, CLSID\r\n#endif\r\n\r\n#include <comdef.h>\r\n#include \"Registry.h\"\r\n#include \"DCOMPLUGIN_COMPONENT_NAMEServer.h\"\r\n#include \"DCOMP", 200);
      mBuffer.append("LUGIN_COMPONENT_NAMEServerImpl.h\"\r\n#include \"DCOMPLUGIN_PROTO_FILE_NAME.pb.h\"\r\n#include \"stdio.h\"\r\n#include \"stdlib.h\"\r\n\r\n#pragma comment(lib, \"rpcrt4\" )\r\n#pragma comment(lib, \"ole32\" ) \r\n\r\n#include \"", 200);
      mBuffer.append("MessageSerializer.h\"\r\n#include \"ErrorHandlers.h\"\r\n\r\n#include \"WinError.h\"\r\n\r\n// Count of active components\r\nstatic long g_cComponents = 0 ;\r\n\r\n// Count of locks\r\nstatic long g_cServerLocks = 0 ;\r\n\r\n//", 200);
      mBuffer.append(" DLL module handle\r\nstatic HMODULE g_hModule = NULL ;\r\n\r\n// Friendly name of component\r\nconst char g_szFriendlyName[] = \"DCOMPLUGIN_OBJECT_FRIENDLYNAME\";\r\n\r\n// Version-independent ProgID of component\r", 200);
      mBuffer.append("\nconst char g_szVerIndProgID[] = \"DCOMPLUGIN_OBJECT_NAME\";\r\n\r\n// ProgID of component\r\nconst char g_szProgID[] = \"DCOMPLUGIN_OBJECT_NAME.1\";\r\n\r\n// AppID\r\nconst char g_szAppID[] = \"{DCOMPLUGIN_APPID_GUI", 200);
      mBuffer.append("D}\";\r\n\r\n\r\n// Actual server implementation\r\nDCOMPLUGIN_PACKAGE_NAME::DCOMPLUGIN_COMPONENT_NAMEServerImpl g_objDCOMPLUGIN_COMPONENT_NAMEServerImpl;\r\n\r\n//\r\n// Constructor\r\n//\r\nCoDCOMPLUGIN_COMPONENT_NAME", 200);
      mBuffer.append("Server::CoDCOMPLUGIN_COMPONENT_NAMEServer() : m_cRef(1)\r\n{ \r\n  InterlockedIncrement(&g_cComponents) ; \r\n\r\n  m_ptinfo = NULL;\r\n  LoadTypeInfo(&m_ptinfo, LIBID_DCOMPLUGIN_LIBRARY_NAME, IID_DCOMPLUGIN_ID", 200);
      mBuffer.append("L_INTERFACE_NAMEServer, 0);\r\n}\r\n\r\n//\r\n// Destructor\r\n//\r\nCoDCOMPLUGIN_COMPONENT_NAMEServer::~CoDCOMPLUGIN_COMPONENT_NAMEServer() \r\n{ \r\n  InterlockedDecrement(&g_cComponents) ; \r\n}\r\n\r\n//\r\n// IUnknown i", 200);
      mBuffer.append("mplementation\r\n//\r\nHRESULT __stdcall CoDCOMPLUGIN_COMPONENT_NAMEServer::QueryInterface(const IID& iid, void** ppv)\r\n{    \r\n  if (iid == IID_IUnknown || iid == IID_DCOMPLUGIN_IDL_INTERFACE_NAMEServer |", 200);
      mBuffer.append("| iid == IID_IDispatch)\r\n  {\r\n    *ppv = static_cast<DCOMPLUGIN_IDL_INTERFACE_NAMEServer*>(this) ; \r\n  }\r\n  else\r\n  {\r\n    *ppv = NULL ;\r\n    return E_NOINTERFACE ;\r\n  }\r\n  reinterpret_cast<IUnknown*>", 200);
      mBuffer.append("(*ppv)->AddRef() ;\r\n  return S_OK ;\r\n}\r\n\r\nULONG __stdcall CoDCOMPLUGIN_COMPONENT_NAMEServer::AddRef()\r\n{\r\n  return InterlockedIncrement(&m_cRef) ;\r\n}\r\n\r\nULONG __stdcall CoDCOMPLUGIN_COMPONENT_NAMEServ", 200);
      mBuffer.append("er::Release() \r\n{\r\n  if (InterlockedDecrement(&m_cRef) == 0)\r\n  {\r\n    delete this ;\r\n    ::PostMessage(NULL,WM_QUIT,0,0);\r\n    return 0 ;\r\n  }\r\n  return m_cRef ;\r\n}\r\n\r\nDCOMPLUGIN_COCLASS_DEFINITION\r\n", 200);
      mBuffer.append("\r\nHRESULT CoDCOMPLUGIN_COMPONENT_NAMEServer::LoadTypeInfo(ITypeInfo ** pptinfo, const CLSID &libid, const CLSID &iid, LCID lcid)\r\n{\r\n   HRESULT hr;\r\n   LPTYPELIB ptlib = NULL;\r\n   LPTYPEINFO ptinfo = ", 200);
      mBuffer.append("NULL;\r\n\r\n   *pptinfo = NULL;\r\n\r\n   // Load type library.\r\n   hr = LoadRegTypeLib(libid, 1, 0, lcid, &ptlib);\r\n   if (FAILED(hr))\r\n      return hr;\r\n\r\n   // Get type information for interface of the ob", 200);
      mBuffer.append("ject.\r\n   hr = ptlib->GetTypeInfoOfGuid(iid, &ptinfo);\r\n   if (FAILED(hr))\r\n   {\r\n      ptlib->Release();\r\n      return hr;\r\n   }\r\n\r\n   ptlib->Release();\r\n   *pptinfo = ptinfo;\r\n   return NOERROR;\r\n}\r", 200);
      mBuffer.append("\n\r\n\r\nHRESULT __stdcall CoDCOMPLUGIN_COMPONENT_NAMEServer::GetTypeInfoCount(UINT* pctinfo)\r\n{\r\n  *pctinfo = 1;\r\n  return S_OK;\r\n}\r\nHRESULT __stdcall CoDCOMPLUGIN_COMPONENT_NAMEServer::GetTypeInfo(UINT ", 200);
      mBuffer.append("itinfo, LCID lcid, ITypeInfo** pptinfo)\r\n{\r\n  *pptinfo = NULL;\r\n\r\n  if(itinfo != 0)\r\n    return ResultFromScode(DISP_E_BADINDEX);\r\n\r\n  m_ptinfo->AddRef();      // AddRef and return pointer to cached\r\n", 200);
      mBuffer.append("                           // typeinfo for this object.\r\n  *pptinfo = m_ptinfo;\r\n\r\n  return NOERROR;\r\n}\r\nHRESULT __stdcall CoDCOMPLUGIN_COMPONENT_NAMEServer::GetIDsOfNames(REFIID riid, LPOLESTR* rgszN", 200);
      mBuffer.append("ames, UINT cNames,\r\n    LCID lcid, DISPID* rgdispid)\r\n{\r\n  return DispGetIDsOfNames(m_ptinfo, rgszNames, cNames, rgdispid);\r\n}\r\nHRESULT __stdcall CoDCOMPLUGIN_COMPONENT_NAMEServer::Invoke(DISPID dispi", 200);
      mBuffer.append("dMember, REFIID riid,\r\n    LCID lcid, WORD wFlags, DISPPARAMS* pdispparams, VARIANT* pvarResult,\r\n    EXCEPINFO* pexcepinfo, UINT* puArgErr)\r\n{\r\n  return DispInvoke(\r\n        this, m_ptinfo,\r\n        ", 200);
      mBuffer.append("dispidMember, wFlags, pdispparams,\r\n        pvarResult, pexcepinfo, puArgErr); \r\n}\r\n\r\n\r\n//\r\n// Class factory IUnknown implementation\r\n//\r\nHRESULT __stdcall CFactory::QueryInterface(const IID& iid, voi", 200);
      mBuffer.append("d** ppv)\r\n{    \r\n  if ((iid == IID_IUnknown) || (iid == IID_IClassFactory))\r\n  {\r\n    *ppv = static_cast<IClassFactory*>(this) ; \r\n  }\r\n  else\r\n  {\r\n    *ppv = NULL ;\r\n    return E_NOINTERFACE ;\r\n  }\r", 200);
      mBuffer.append("\n  reinterpret_cast<IUnknown*>(*ppv)->AddRef() ;\r\n  return S_OK ;\r\n}\r\n\r\nULONG __stdcall CFactory::AddRef()\r\n{\r\n  return InterlockedIncrement(&m_cRef) ;\r\n}\r\n\r\nULONG __stdcall CFactory::Release() \r\n{\r\n ", 200);
      mBuffer.append(" if (InterlockedDecrement(&m_cRef) == 0)\r\n  {\r\n    delete this ;\r\n    return 0 ;\r\n  }\r\n  return m_cRef ;\r\n}\r\n\r\n//\r\n// IClassFactory implementation\r\n//\r\nHRESULT __stdcall CFactory::CreateInstance(IUnkn", 200);
      mBuffer.append("own* pUnknownOuter,\r\n                                           const IID& iid,\r\n                                           void** ppv) \r\n{\r\n  // Cannot aggregate.\r\n  if (pUnknownOuter != NULL)\r\n  {\r\n", 200);
      mBuffer.append("    return CLASS_E_NOAGGREGATION ;\r\n  }\r\n\r\n  // Create component.\r\n  CoDCOMPLUGIN_COMPONENT_NAMEServer* pA = new CoDCOMPLUGIN_COMPONENT_NAMEServer ;\r\n  if (pA == NULL)\r\n  {\r\n    return E_OUTOFMEMORY ;", 200);
      mBuffer.append("\r\n  }\r\n\r\n  // Get the requested interface.\r\n  HRESULT hr = pA->QueryInterface(iid, ppv) ;\r\n\r\n  // Release the IUnknown pointer.\r\n  // (If QueryInterface failed, component will delete itself.)\r\n  pA->R", 200);
      mBuffer.append("elease() ;\r\n  return hr ;\r\n}\r\n\r\n// LockServer\r\nHRESULT __stdcall CFactory::LockServer(BOOL bLock) \r\n{\r\n  if (bLock)\r\n  {\r\n    InterlockedIncrement(&g_cServerLocks) ; \r\n  }\r\n  else\r\n  {\r\n    Interlocke", 200);
      mBuffer.append("dDecrement(&g_cServerLocks) ;\r\n  }\r\n  return S_OK ;\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n///////////////////////////////////////////////////////////\r\n//\r\n// Exported functions\r\n//\r\n\r\n//\r\n// Can DLL unload now\?\r\n//\r\nSTDA", 200);
      mBuffer.append("PI DllCanUnloadNow()\r\n{\r\n  if ((g_cComponents == 0) && (g_cServerLocks == 0))\r\n  {\r\n    return S_OK ;\r\n  }\r\n  else\r\n  {\r\n    return S_FALSE ;\r\n  }\r\n}\r\n\r\n//\r\n// Get class factory\r\n//\r\nSTDAPI DllGetClas", 200);
      mBuffer.append("sObject(const CLSID& clsid,\r\n                         const IID& iid,\r\n                         void** ppv)\r\n{\r\n  // Can we create this component\?\r\n  if (clsid != CLSID_CoDCOMPLUGIN_COMPONENT_NAMEServ", 200);
      mBuffer.append("er)\r\n  {\r\n    return CLASS_E_CLASSNOTAVAILABLE ;\r\n  }\r\n\r\n  // Create class factory.\r\n  CFactory* pFactory = new CFactory ;  // Reference count set to 1\r\n                                       // in co", 200);
      mBuffer.append("nstructor\r\n  if (pFactory == NULL)\r\n  {\r\n    return E_OUTOFMEMORY ;\r\n  }\r\n\r\n  // Get requested interface.\r\n  HRESULT hr = pFactory->QueryInterface(iid, ppv) ;\r\n  pFactory->Release() ;\r\n\r\n  return hr ;", 200);
      mBuffer.append("\r\n}\r\n\r\n\r\n\r\n\r\nCFactory gClassFactory;\r\n\r\n\r\n\r\nDWORD CoEXEInitialize()\r\n{\r\n  DWORD nReturn;\r\n\r\n  HRESULT hr=::CoRegisterClassObject(CLSID_CoDCOMPLUGIN_COMPONENT_NAMEServer,\r\n    &gClassFactory,\r\n    CLSC", 200);
      mBuffer.append("TX_SERVER, \r\n    REGCLS_MULTIPLEUSE, \r\n    &nReturn);\r\n\r\n  return nReturn;\r\n}\r\n\r\nvoid CoEXEUninitialize(DWORD nToken)\r\n{\r\n  ::CoRevokeClassObject(nToken);\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n//\r\n// Server registr", 200);
      mBuffer.append("ation\r\n//\r\nSTDAPI DllRegisterServer()\r\n{\r\n\r\n  g_hModule = ::GetModuleHandle(NULL);\r\n\r\n  HRESULT hr= RegisterServer(g_hModule,\r\n                             g_szAppID,\r\n                             CLS", 200);
      mBuffer.append("ID_CoDCOMPLUGIN_COMPONENT_NAMEServer,\r\n                             g_szFriendlyName,\r\n                             g_szVerIndProgID,\r\n                             g_szProgID,\r\n                       ", 200);
      mBuffer.append("      LIBID_DCOMPLUGIN_LIBRARY_NAME);\r\n  if (SUCCEEDED(hr))\r\n  {\r\n    hr = RegisterTypeLib( g_hModule, NULL);\r\n  }\r\n  return hr;\r\n}\r\n\r\n\r\n//\r\n// Server unregistration\r\n//\r\nSTDAPI DllUnregisterServer()\r", 200);
      mBuffer.append("\n{\r\n\r\n  g_hModule = ::GetModuleHandle(NULL);\r\n\r\n  HRESULT hr= UnregisterServer(g_hModule,\r\n                               g_szAppID,\r\n                               CLSID_CoDCOMPLUGIN_COMPONENT_NAMESe", 200);
      mBuffer.append("rver,\r\n                               g_szVerIndProgID,\r\n                               g_szProgID,\r\n                               LIBID_DCOMPLUGIN_LIBRARY_NAME);\r\n  if (SUCCEEDED(hr))\r\n  {\r\n    UnRe", 200);
      mBuffer.append("gisterTypeLib( g_hModule, NULL);\r\n  }\r\n  return hr;\r\n}\r\n\r\n\r\n\r\n///////////////////////////////////////////////////////////\r\n//\r\n// DLL module information\r\n//\r\nBOOL APIENTRY DllMain(HANDLE hModule,\r\n   ", 200);
      mBuffer.append("                   DWORD dwReason,\r\n                      void* lpReserved)\r\n{\r\n  if (dwReason == DLL_PROCESS_ATTACH)\r\n  {\r\n    g_hModule = (HMODULE)hModule ;\r\n  }\r\n\r\n  return TRUE ;\r\n}\r\n", 187);
    }
    virtual bool save(const char * iFilename) const
    {
      FILE * f = fopen(iFilename, "wb");
      if (!f) return false;
      size_t fileSize = getSize();
      const char * buffer = getBuffer();
      fwrite(buffer, 1, fileSize, f);
      fclose(f);
      return true;
    }
  private:
    std::string mBuffer;
  };
  const File & getServerCppFile() { static ServerCppFile _instance; return _instance; }
}; //bin2cpp
