/**
 * This file was generated by
 * bin2cpp v1.3.
 * Copyright (C) 2013-2014 end2endzone.com. All rights reserved.
 * Do not modify this file.
 */
#include ".\EmbeddedFileServerCpp.h"
#include <stdio.h> //for FILE
#include <string> //for memcpy
namespace bin2cpp
{
  class ServerCppFile : public virtual bin2cpp::File
  {
  public:
    ServerCppFile() {}
    ~ServerCppFile() {}
    virtual size_t getSize() { return 8414; }
    virtual size_t getSegmentSize() { return 200; }
    virtual size_t getNumSegments() { return 43; }
    virtual const char * getFilename() { return "DCOMPLUGIN_COMPONENT_NAMEServer.cpp"; }
    virtual const char * getSegment(size_t iIndex, size_t & oLength)
    {
      oLength = 0;
      if (iIndex >= getNumSegments())
        return NULL;
      const char * buffer = NULL;
      size_t index = 0;
      oLength = getSegmentSize();
      buffer = "#include <objbase.h> // \x0d\012#include \"DCOMPLUGIN_COMPONENT_NAMEServer_h.h\"\x0d\012#include \"DCOMPLUGIN_COMPONENT_NAMEServer_i.c\"\x0d\012#include <comdef.h>\x0d\012#include \"Registry.h\"\x0d\012#include \"DCOMPLUGIN_COMPONENT_NAM"; if (iIndex == index) return buffer; index++;
      buffer = "EServer.h\"\x0d\012#include \"DCOMPLUGIN_COMPONENT_NAMEServerImpl.h\"\x0d\012#include \"DCOMPLUGIN_PROTO_FILE_NAME.pb.h\"\x0d\012#include \"stdio.h\"\x0d\012#include \"stdlib.h\"\x0d\x0a\x0d\012#pragma comment(lib, \"rpcrt4\" )\x0d\012#pragma comment(li"; if (iIndex == index) return buffer; index++;
      buffer = "b, \"ole32\" ) \x0d\x0a\x0d\012#include \"MessageSerializer.h\"\x0d\012#include \"ErrorHandlers.h\"\x0d\x0a\x0d\012#include \"WinError.h\"\x0d\x0a\x0d\012// Count of active components\x0d\012static long g_cComponents = 0 ;\x0d\x0a\x0d\012// Count of locks\x0d\012static long"; if (iIndex == index) return buffer; index++;
      buffer = " g_cServerLocks = 0 ;\x0d\x0a\x0d\012// DLL module handle\x0d\012static HMODULE g_hModule = NULL ;\x0d\x0a\x0d\012// Friendly name of component\x0d\012const char g_szFriendlyName[] = \"DCOMPLUGIN_OBJECT_FRIENDLYNAME\";\x0d\x0a\x0d\012// Version-indep"; if (iIndex == index) return buffer; index++;
      buffer = "endent ProgID of component\x0d\012const char g_szVerIndProgID[] = \"DCOMPLUGIN_OBJECT_NAME\";\x0d\x0a\x0d\012// ProgID of component\x0d\012const char g_szProgID[] = \"DCOMPLUGIN_OBJECT_NAME.1\";\x0d\x0a\x0d\012// AppID\x0d\012const char g_szAppID"; if (iIndex == index) return buffer; index++;
      buffer = "[] = \"{DCOMPLUGIN_APPID_GUID}\";\x0d\x0a\x0d\x0a\x0d\012// Actual server implementation\x0d\012DCOMPLUGIN_PACKAGE_NAME::DCOMPLUGIN_COMPONENT_NAMEServerImpl g_objDCOMPLUGIN_COMPONENT_NAMEServerImpl;\x0d\x0a\x0d\012//\x0d\012// Constructor\x0d\012//\x0d\x0a"; if (iIndex == index) return buffer; index++;
      buffer = "CoDCOMPLUGIN_COMPONENT_NAMEServer::CoDCOMPLUGIN_COMPONENT_NAMEServer() : m_cRef(1)\x0d\012{ \x0d\012  InterlockedIncrement(&g_cComponents) ; \x0d\x0a\x0d\012  m_ptinfo = NULL;\x0d\012  LoadTypeInfo(&m_ptinfo, LIBID_DCOMPLUGIN_LIBR"; if (iIndex == index) return buffer; index++;
      buffer = "ARY_NAME, IID_DCOMPLUGIN_IDL_INTERFACE_NAMEServer, 0);\x0d\012}\x0d\x0a\x0d\012//\x0d\012// Destructor\x0d\012//\x0d\012CoDCOMPLUGIN_COMPONENT_NAMEServer::~CoDCOMPLUGIN_COMPONENT_NAMEServer() \x0d\012{ \x0d\012  InterlockedDecrement(&g_cComponents)"; if (iIndex == index) return buffer; index++;
      buffer = " ; \x0d\012}\x0d\x0a\x0d\012//\x0d\012// IUnknown implementation\x0d\012//\x0d\012HRESULT __stdcall CoDCOMPLUGIN_COMPONENT_NAMEServer::QueryInterface(const IID& iid, void** ppv)\x0d\012{    \x0d\012  if (iid == IID_IUnknown || iid == IID_DCOMPLUGIN"; if (iIndex == index) return buffer; index++;
      buffer = "_IDL_INTERFACE_NAMEServer || iid == IID_IDispatch)\x0d\012  {\x0d\012    *ppv = static_cast<DCOMPLUGIN_IDL_INTERFACE_NAMEServer*>(this) ; \x0d\012  }\x0d\012  else\x0d\012  {\x0d\012    *ppv = NULL ;\x0d\012    return E_NOINTERFACE ;\x0d\012  }\x0d\012  "; if (iIndex == index) return buffer; index++;
      buffer = "reinterpret_cast<IUnknown*>(*ppv)->AddRef() ;\x0d\012  return S_OK ;\x0d\012}\x0d\x0a\x0d\012ULONG __stdcall CoDCOMPLUGIN_COMPONENT_NAMEServer::AddRef()\x0d\012{\x0d\012  return InterlockedIncrement(&m_cRef) ;\x0d\012}\x0d\x0a\x0d\012ULONG __stdcall CoDC"; if (iIndex == index) return buffer; index++;
      buffer = "OMPLUGIN_COMPONENT_NAMEServer::Release() \x0d\012{\x0d\012  if (InterlockedDecrement(&m_cRef) == 0)\x0d\012  {\x0d\012    delete this ;\x0d\012    ::PostMessage(NULL,WM_QUIT,0,0);\x0d\012    return 0 ;\x0d\012  }\x0d\012  return m_cRef ;\x0d\012}\x0d\x0a\x0d\012DCOM"; if (iIndex == index) return buffer; index++;
      buffer = "PLUGIN_COCLASS_DEFINITION\x0d\x0a\x0d\012HRESULT CoDCOMPLUGIN_COMPONENT_NAMEServer::LoadTypeInfo(ITypeInfo ** pptinfo, const CLSID &libid, const CLSID &iid, LCID lcid)\x0d\012{\x0d\012   HRESULT hr;\x0d\012   LPTYPELIB ptlib = NUL"; if (iIndex == index) return buffer; index++;
      buffer = "L;\x0d\012   LPTYPEINFO ptinfo = NULL;\x0d\x0a\x0d\012   *pptinfo = NULL;\x0d\x0a\x0d\012   // Load type library.\x0d\012   hr = LoadRegTypeLib(libid, 1, 0, lcid, &ptlib);\x0d\012   if (FAILED(hr))\x0d\012      return hr;\x0d\x0a\x0d\012   // Get type informat"; if (iIndex == index) return buffer; index++;
      buffer = "ion for interface of the object.\x0d\012   hr = ptlib->GetTypeInfoOfGuid(iid, &ptinfo);\x0d\012   if (FAILED(hr))\x0d\012   {\x0d\012      ptlib->Release();\x0d\012      return hr;\x0d\012   }\x0d\x0a\x0d\012   ptlib->Release();\x0d\012   *pptinfo = ptin"; if (iIndex == index) return buffer; index++;
      buffer = "fo;\x0d\012   return NOERROR;\x0d\012}\x0d\x0a\x0d\x0a\x0d\012HRESULT __stdcall CoDCOMPLUGIN_COMPONENT_NAMEServer::GetTypeInfoCount(UINT* pctinfo)\x0d\012{\x0d\012  *pctinfo = 1;\x0d\012  return S_OK;\x0d\012}\x0d\012HRESULT __stdcall CoDCOMPLUGIN_COMPONENT_NA"; if (iIndex == index) return buffer; index++;
      buffer = "MEServer::GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo** pptinfo)\x0d\012{\x0d\012  *pptinfo = NULL;\x0d\x0a\x0d\012  if(itinfo != 0)\x0d\012    return ResultFromScode(DISP_E_BADINDEX);\x0d\x0a\x0d\012  m_ptinfo->AddRef();      // AddRef and"; if (iIndex == index) return buffer; index++;
      buffer = " return pointer to cached\x0d\012                           // typeinfo for this object.\x0d\012  *pptinfo = m_ptinfo;\x0d\x0a\x0d\012  return NOERROR;\x0d\012}\x0d\012HRESULT __stdcall CoDCOMPLUGIN_COMPONENT_NAMEServer::GetIDsOfNames(R"; if (iIndex == index) return buffer; index++;
      buffer = "EFIID riid, LPOLESTR* rgszNames, UINT cNames,\x0d\012    LCID lcid, DISPID* rgdispid)\x0d\012{\x0d\012  return DispGetIDsOfNames(m_ptinfo, rgszNames, cNames, rgdispid);\x0d\012}\x0d\012HRESULT __stdcall CoDCOMPLUGIN_COMPONENT_NAME"; if (iIndex == index) return buffer; index++;
      buffer = "Server::Invoke(DISPID dispidMember, REFIID riid,\x0d\012    LCID lcid, WORD wFlags, DISPPARAMS* pdispparams, VARIANT* pvarResult,\x0d\012    EXCEPINFO* pexcepinfo, UINT* puArgErr)\x0d\012{\x0d\012  return DispInvoke(\x0d\012      "; if (iIndex == index) return buffer; index++;
      buffer = "  this, m_ptinfo,\x0d\012        dispidMember, wFlags, pdispparams,\x0d\012        pvarResult, pexcepinfo, puArgErr); \x0d\012}\x0d\x0a\x0d\x0a\x0d\012//\x0d\012// Class factory IUnknown implementation\x0d\012//\x0d\012HRESULT __stdcall CFactory::QueryIn"; if (iIndex == index) return buffer; index++;
      buffer = "terface(const IID& iid, void** ppv)\x0d\012{    \x0d\012  if ((iid == IID_IUnknown) || (iid == IID_IClassFactory))\x0d\012  {\x0d\012    *ppv = static_cast<IClassFactory*>(this) ; \x0d\012  }\x0d\012  else\x0d\012  {\x0d\012    *ppv = NULL ;\x0d\012    r"; if (iIndex == index) return buffer; index++;
      buffer = "eturn E_NOINTERFACE ;\x0d\012  }\x0d\012  reinterpret_cast<IUnknown*>(*ppv)->AddRef() ;\x0d\012  return S_OK ;\x0d\012}\x0d\x0a\x0d\012ULONG __stdcall CFactory::AddRef()\x0d\012{\x0d\012  return InterlockedIncrement(&m_cRef) ;\x0d\012}\x0d\x0a\x0d\012ULONG __stdcall"; if (iIndex == index) return buffer; index++;
      buffer = " CFactory::Release() \x0d\012{\x0d\012  if (InterlockedDecrement(&m_cRef) == 0)\x0d\012  {\x0d\012    delete this ;\x0d\012    return 0 ;\x0d\012  }\x0d\012  return m_cRef ;\x0d\012}\x0d\x0a\x0d\012//\x0d\012// IClassFactory implementation\x0d\012//\x0d\012HRESULT __stdcall CFa"; if (iIndex == index) return buffer; index++;
      buffer = "ctory::CreateInstance(IUnknown* pUnknownOuter,\x0d\012                                           const IID& iid,\x0d\012                                           void** ppv) \x0d\012{\x0d\012  // Cannot aggregate.\x0d\012  if (pU"; if (iIndex == index) return buffer; index++;
      buffer = "nknownOuter != NULL)\x0d\012  {\x0d\012    return CLASS_E_NOAGGREGATION ;\x0d\012  }\x0d\x0a\x0d\012  // Create component.\x0d\012  CoDCOMPLUGIN_COMPONENT_NAMEServer* pA = new CoDCOMPLUGIN_COMPONENT_NAMEServer ;\x0d\012  if (pA == NULL)\x0d\012  {\x0d"; if (iIndex == index) return buffer; index++;
      buffer = "\012    return E_OUTOFMEMORY ;\x0d\012  }\x0d\x0a\x0d\012  // Get the requested interface.\x0d\012  HRESULT hr = pA->QueryInterface(iid, ppv) ;\x0d\x0a\x0d\012  // Release the IUnknown pointer.\x0d\012  // (If QueryInterface failed, component wi"; if (iIndex == index) return buffer; index++;
      buffer = "ll delete itself.)\x0d\012  pA->Release() ;\x0d\012  return hr ;\x0d\012}\x0d\x0a\x0d\012// LockServer\x0d\012HRESULT __stdcall CFactory::LockServer(BOOL bLock) \x0d\012{\x0d\012  if (bLock)\x0d\012  {\x0d\012    InterlockedIncrement(&g_cServerLocks) ; \x0d\012  }\x0d\x0a"; if (iIndex == index) return buffer; index++;
      buffer = "  else\x0d\012  {\x0d\012    InterlockedDecrement(&g_cServerLocks) ;\x0d\012  }\x0d\012  return S_OK ;\x0d\012}\x0d\x0a\x0d\x0a\x0d\x0a\x0d\x0a\x0d\x0a\x0d\x0a\x0d\x0a\x0d\012///////////////////////////////////////////////////////////\x0d\012//\x0d\012// Exported functions\x0d\012//\x0d\x0a\x0d\012//\x0d\012// Ca"; if (iIndex == index) return buffer; index++;
      buffer = "n DLL unload now?\x0d\012//\x0d\012STDAPI DllCanUnloadNow()\x0d\012{\x0d\012  if ((g_cComponents == 0) && (g_cServerLocks == 0))\x0d\012  {\x0d\012    return S_OK ;\x0d\012  }\x0d\012  else\x0d\012  {\x0d\012    return S_FALSE ;\x0d\012  }\x0d\012}\x0d\x0a\x0d\012//\x0d\012// Get class fac"; if (iIndex == index) return buffer; index++;
      buffer = "tory\x0d\012//\x0d\012STDAPI DllGetClassObject(const CLSID& clsid,\x0d\012                         const IID& iid,\x0d\012                         void** ppv)\x0d\012{\x0d\012  // Can we create this component?\x0d\012  if (clsid != CLSID_CoDC"; if (iIndex == index) return buffer; index++;
      buffer = "OMPLUGIN_COMPONENT_NAMEServer)\x0d\012  {\x0d\012    return CLASS_E_CLASSNOTAVAILABLE ;\x0d\012  }\x0d\x0a\x0d\012  // Create class factory.\x0d\012  CFactory* pFactory = new CFactory ;  // Reference count set to 1\x0d\012                    "; if (iIndex == index) return buffer; index++;
      buffer = "                   // in constructor\x0d\012  if (pFactory == NULL)\x0d\012  {\x0d\012    return E_OUTOFMEMORY ;\x0d\012  }\x0d\x0a\x0d\012  // Get requested interface.\x0d\012  HRESULT hr = pFactory->QueryInterface(iid, ppv) ;\x0d\012  pFactory->R"; if (iIndex == index) return buffer; index++;
      buffer = "elease() ;\x0d\x0a\x0d\012  return hr ;\x0d\012}\x0d\x0a\x0d\x0a\x0d\x0a\x0d\x0a\x0d\012CFactory gClassFactory;\x0d\x0a\x0d\x0a\x0d\x0a\x0d\012DWORD CoEXEInitialize()\x0d\012{\x0d\012  DWORD nReturn;\x0d\x0a\x0d\012  HRESULT hr=::CoRegisterClassObject(CLSID_CoDCOMPLUGIN_COMPONENT_NAMEServer,\x0d\012  "; if (iIndex == index) return buffer; index++;
      buffer = "  &gClassFactory,\x0d\012    CLSCTX_SERVER, \x0d\012    REGCLS_MULTIPLEUSE, \x0d\012    &nReturn);\x0d\x0a\x0d\012  return nReturn;\x0d\012}\x0d\x0a\x0d\012void CoEXEUninitialize(DWORD nToken)\x0d\012{\x0d\012  ::CoRevokeClassObject(nToken);\x0d\012}\x0d\x0a\x0d\x0a\x0d\x0a\x0d\x0a\x0d\x0a\x0d\x0a\x0d\x0a\x0d\x0a"; if (iIndex == index) return buffer; index++;
      buffer = "\x0d\x0a\x0d\x0a\x0d\012//\x0d\012// Server registration\x0d\012//\x0d\012STDAPI DllRegisterServer()\x0d\012{\x0d\x0a\x0d\012  g_hModule = ::GetModuleHandle(NULL);\x0d\x0a\x0d\012  HRESULT hr= RegisterServer(g_hModule,\x0d\012                             g_szAppID,\x0d\012     "; if (iIndex == index) return buffer; index++;
      buffer = "                        CLSID_CoDCOMPLUGIN_COMPONENT_NAMEServer,\x0d\012                             g_szFriendlyName,\x0d\012                             g_szVerIndProgID,\x0d\012                             g_szProgI"; if (iIndex == index) return buffer; index++;
      buffer = "D,\x0d\012                             LIBID_DCOMPLUGIN_LIBRARY_NAME);\x0d\012  if (SUCCEEDED(hr))\x0d\012  {\x0d\012    hr = RegisterTypeLib( g_hModule, NULL);\x0d\012  }\x0d\012  return hr;\x0d\012}\x0d\x0a\x0d\x0a\x0d\012//\x0d\012// Server unregistration\x0d\012//\x0d\012ST"; if (iIndex == index) return buffer; index++;
      buffer = "DAPI DllUnregisterServer()\x0d\012{\x0d\x0a\x0d\012  g_hModule = ::GetModuleHandle(NULL);\x0d\x0a\x0d\012  HRESULT hr= UnregisterServer(g_hModule,\x0d\012                               g_szAppID,\x0d\012                               CLSID_Co"; if (iIndex == index) return buffer; index++;
      buffer = "DCOMPLUGIN_COMPONENT_NAMEServer,\x0d\012                               g_szVerIndProgID,\x0d\012                               g_szProgID,\x0d\012                               LIBID_DCOMPLUGIN_LIBRARY_NAME);\x0d\012  if (SU"; if (iIndex == index) return buffer; index++;
      buffer = "CCEEDED(hr))\x0d\012  {\x0d\012    UnRegisterTypeLib( g_hModule, NULL);\x0d\012  }\x0d\012  return hr;\x0d\012}\x0d\x0a\x0d\x0a\x0d\x0a\x0d\012///////////////////////////////////////////////////////////\x0d\012//\x0d\012// DLL module information\x0d\012//\x0d\012BOOL APIENTRY D"; if (iIndex == index) return buffer; index++;
      buffer = "llMain(HANDLE hModule,\x0d\012                      DWORD dwReason,\x0d\012                      void* lpReserved)\x0d\012{\x0d\012  if (dwReason == DLL_PROCESS_ATTACH)\x0d\012  {\x0d\012    g_hModule = (HMODULE)hModule ;\x0d\012  }\x0d\x0a\x0d\012  retu"; if (iIndex == index) return buffer; index++;
      oLength = 14;
      buffer = "rn TRUE ;\x0d\012}\x0d\x0a"; if (iIndex == index) return buffer; index++;
      oLength = 0;
      return NULL;
    }
    virtual const char * getMd5() { return "a34784e49e82970ad09bcbb17af9ccce"; }
    virtual char * newBuffer()
    {
      size_t size = getSize();
      char * buffer = new char[size];
      if (buffer == NULL)
        return NULL;
      size_t numSegments = getNumSegments();
      size_t segmentLength = 0;
      size_t index = 0;
      for(size_t i=0; i<numSegments; i++)
      {
        const char * segmentBuffer = getSegment(i, segmentLength);
        memcpy(&buffer[index], segmentBuffer, segmentLength);
        index += segmentLength;
      }
      return buffer;
    }
    virtual bool save(const char * iFilename)
    {
      FILE * f = fopen(iFilename, "wb");
      if (!f) return false;
      size_t numSegments = getNumSegments();
      size_t segmentLength = 0;
      const char * buffer = NULL;
      for(size_t i=0; i<numSegments; i++)
      {
        buffer = getSegment(i, segmentLength);
        fwrite(buffer, 1, segmentLength, f);
      }
      fclose(f);
      return true;
    }
  };
  File & getServerCppFile() { static ServerCppFile _instance; return _instance; }
}; //bin2cpp
