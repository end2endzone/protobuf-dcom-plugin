/**
 * This file was generated by bin2cpp v2.2.0
 * Copyright (C) 2013-2019 end2endzone.com. All rights reserved.
 * bin2cpp is open source software, see http://github.com/end2endzone/bin2cpp
 * Source code for file 'DCOMPLUGIN_COMPONENT_NAMEServer.cpp', last modified 1552228002.
 * Do not modify this file.
 */
#include "EmbeddedFileServerCpp.h"
#include <stdio.h> //for FILE
#include <string> //for memcpy
namespace bin2cpp
{
  class ServerCppFile : public virtual bin2cpp::File
  {
  public:
    ServerCppFile() { build(); }
    virtual ~ServerCppFile() {}
    virtual size_t getSize() const { return 8414; }
    virtual const char * getFilename() const { return "DCOMPLUGIN_COMPONENT_NAMEServer.cpp"; }
    virtual const char * getBuffer() const { return mBuffer.c_str(); }
    void build()
    {
      mBuffer.clear();
      mBuffer.reserve(getSize()); //allocate all required memory at once to prevent reallocations
      mBuffer.append("#include <objbase.h> // \r\n#include \"DCOMPLUGIN_COMPONENT_NAMEServer_h.h\"\r\n#include \"DCOMPLUGIN_COMPONENT_NAMEServer_i.c\"\r\n#include <comdef.h>\r\n#include \"Registry.h\"\r\n#include \"DCOMPLUGIN_COMPONENT_NAM", 200);
      mBuffer.append("EServer.h\"\r\n#include \"DCOMPLUGIN_COMPONENT_NAMEServerImpl.h\"\r\n#include \"DCOMPLUGIN_PROTO_FILE_NAME.pb.h\"\r\n#include \"stdio.h\"\r\n#include \"stdlib.h\"\r\n\r\n#pragma comment(lib, \"rpcrt4\" )\r\n#pragma comment(li", 200);
      mBuffer.append("b, \"ole32\" ) \r\n\r\n#include \"MessageSerializer.h\"\r\n#include \"ErrorHandlers.h\"\r\n\r\n#include \"WinError.h\"\r\n\r\n// Count of active components\r\nstatic long g_cComponents = 0 ;\r\n\r\n// Count of locks\r\nstatic long", 200);
      mBuffer.append(" g_cServerLocks = 0 ;\r\n\r\n// DLL module handle\r\nstatic HMODULE g_hModule = NULL ;\r\n\r\n// Friendly name of component\r\nconst char g_szFriendlyName[] = \"DCOMPLUGIN_OBJECT_FRIENDLYNAME\";\r\n\r\n// Version-indep", 200);
      mBuffer.append("endent ProgID of component\r\nconst char g_szVerIndProgID[] = \"DCOMPLUGIN_OBJECT_NAME\";\r\n\r\n// ProgID of component\r\nconst char g_szProgID[] = \"DCOMPLUGIN_OBJECT_NAME.1\";\r\n\r\n// AppID\r\nconst char g_szAppID", 200);
      mBuffer.append("[] = \"{DCOMPLUGIN_APPID_GUID}\";\r\n\r\n\r\n// Actual server implementation\r\nDCOMPLUGIN_PACKAGE_NAME::DCOMPLUGIN_COMPONENT_NAMEServerImpl g_objDCOMPLUGIN_COMPONENT_NAMEServerImpl;\r\n\r\n//\r\n// Constructor\r\n//\r\n", 200);
      mBuffer.append("CoDCOMPLUGIN_COMPONENT_NAMEServer::CoDCOMPLUGIN_COMPONENT_NAMEServer() : m_cRef(1)\r\n{ \r\n  InterlockedIncrement(&g_cComponents) ; \r\n\r\n  m_ptinfo = NULL;\r\n  LoadTypeInfo(&m_ptinfo, LIBID_DCOMPLUGIN_LIBR", 200);
      mBuffer.append("ARY_NAME, IID_DCOMPLUGIN_IDL_INTERFACE_NAMEServer, 0);\r\n}\r\n\r\n//\r\n// Destructor\r\n//\r\nCoDCOMPLUGIN_COMPONENT_NAMEServer::~CoDCOMPLUGIN_COMPONENT_NAMEServer() \r\n{ \r\n  InterlockedDecrement(&g_cComponents)", 200);
      mBuffer.append(" ; \r\n}\r\n\r\n//\r\n// IUnknown implementation\r\n//\r\nHRESULT __stdcall CoDCOMPLUGIN_COMPONENT_NAMEServer::QueryInterface(const IID& iid, void** ppv)\r\n{    \r\n  if (iid == IID_IUnknown || iid == IID_DCOMPLUGIN", 200);
      mBuffer.append("_IDL_INTERFACE_NAMEServer || iid == IID_IDispatch)\r\n  {\r\n    *ppv = static_cast<DCOMPLUGIN_IDL_INTERFACE_NAMEServer*>(this) ; \r\n  }\r\n  else\r\n  {\r\n    *ppv = NULL ;\r\n    return E_NOINTERFACE ;\r\n  }\r\n  ", 200);
      mBuffer.append("reinterpret_cast<IUnknown*>(*ppv)->AddRef() ;\r\n  return S_OK ;\r\n}\r\n\r\nULONG __stdcall CoDCOMPLUGIN_COMPONENT_NAMEServer::AddRef()\r\n{\r\n  return InterlockedIncrement(&m_cRef) ;\r\n}\r\n\r\nULONG __stdcall CoDC", 200);
      mBuffer.append("OMPLUGIN_COMPONENT_NAMEServer::Release() \r\n{\r\n  if (InterlockedDecrement(&m_cRef) == 0)\r\n  {\r\n    delete this ;\r\n    ::PostMessage(NULL,WM_QUIT,0,0);\r\n    return 0 ;\r\n  }\r\n  return m_cRef ;\r\n}\r\n\r\nDCOM", 200);
      mBuffer.append("PLUGIN_COCLASS_DEFINITION\r\n\r\nHRESULT CoDCOMPLUGIN_COMPONENT_NAMEServer::LoadTypeInfo(ITypeInfo ** pptinfo, const CLSID &libid, const CLSID &iid, LCID lcid)\r\n{\r\n   HRESULT hr;\r\n   LPTYPELIB ptlib = NUL", 200);
      mBuffer.append("L;\r\n   LPTYPEINFO ptinfo = NULL;\r\n\r\n   *pptinfo = NULL;\r\n\r\n   // Load type library.\r\n   hr = LoadRegTypeLib(libid, 1, 0, lcid, &ptlib);\r\n   if (FAILED(hr))\r\n      return hr;\r\n\r\n   // Get type informat", 200);
      mBuffer.append("ion for interface of the object.\r\n   hr = ptlib->GetTypeInfoOfGuid(iid, &ptinfo);\r\n   if (FAILED(hr))\r\n   {\r\n      ptlib->Release();\r\n      return hr;\r\n   }\r\n\r\n   ptlib->Release();\r\n   *pptinfo = ptin", 200);
      mBuffer.append("fo;\r\n   return NOERROR;\r\n}\r\n\r\n\r\nHRESULT __stdcall CoDCOMPLUGIN_COMPONENT_NAMEServer::GetTypeInfoCount(UINT* pctinfo)\r\n{\r\n  *pctinfo = 1;\r\n  return S_OK;\r\n}\r\nHRESULT __stdcall CoDCOMPLUGIN_COMPONENT_NA", 200);
      mBuffer.append("MEServer::GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo** pptinfo)\r\n{\r\n  *pptinfo = NULL;\r\n\r\n  if(itinfo != 0)\r\n    return ResultFromScode(DISP_E_BADINDEX);\r\n\r\n  m_ptinfo->AddRef();      // AddRef and", 200);
      mBuffer.append(" return pointer to cached\r\n                           // typeinfo for this object.\r\n  *pptinfo = m_ptinfo;\r\n\r\n  return NOERROR;\r\n}\r\nHRESULT __stdcall CoDCOMPLUGIN_COMPONENT_NAMEServer::GetIDsOfNames(R", 200);
      mBuffer.append("EFIID riid, LPOLESTR* rgszNames, UINT cNames,\r\n    LCID lcid, DISPID* rgdispid)\r\n{\r\n  return DispGetIDsOfNames(m_ptinfo, rgszNames, cNames, rgdispid);\r\n}\r\nHRESULT __stdcall CoDCOMPLUGIN_COMPONENT_NAME", 200);
      mBuffer.append("Server::Invoke(DISPID dispidMember, REFIID riid,\r\n    LCID lcid, WORD wFlags, DISPPARAMS* pdispparams, VARIANT* pvarResult,\r\n    EXCEPINFO* pexcepinfo, UINT* puArgErr)\r\n{\r\n  return DispInvoke(\r\n      ", 200);
      mBuffer.append("  this, m_ptinfo,\r\n        dispidMember, wFlags, pdispparams,\r\n        pvarResult, pexcepinfo, puArgErr); \r\n}\r\n\r\n\r\n//\r\n// Class factory IUnknown implementation\r\n//\r\nHRESULT __stdcall CFactory::QueryIn", 200);
      mBuffer.append("terface(const IID& iid, void** ppv)\r\n{    \r\n  if ((iid == IID_IUnknown) || (iid == IID_IClassFactory))\r\n  {\r\n    *ppv = static_cast<IClassFactory*>(this) ; \r\n  }\r\n  else\r\n  {\r\n    *ppv = NULL ;\r\n    r", 200);
      mBuffer.append("eturn E_NOINTERFACE ;\r\n  }\r\n  reinterpret_cast<IUnknown*>(*ppv)->AddRef() ;\r\n  return S_OK ;\r\n}\r\n\r\nULONG __stdcall CFactory::AddRef()\r\n{\r\n  return InterlockedIncrement(&m_cRef) ;\r\n}\r\n\r\nULONG __stdcall", 200);
      mBuffer.append(" CFactory::Release() \r\n{\r\n  if (InterlockedDecrement(&m_cRef) == 0)\r\n  {\r\n    delete this ;\r\n    return 0 ;\r\n  }\r\n  return m_cRef ;\r\n}\r\n\r\n//\r\n// IClassFactory implementation\r\n//\r\nHRESULT __stdcall CFa", 200);
      mBuffer.append("ctory::CreateInstance(IUnknown* pUnknownOuter,\r\n                                           const IID& iid,\r\n                                           void** ppv) \r\n{\r\n  // Cannot aggregate.\r\n  if (pU", 200);
      mBuffer.append("nknownOuter != NULL)\r\n  {\r\n    return CLASS_E_NOAGGREGATION ;\r\n  }\r\n\r\n  // Create component.\r\n  CoDCOMPLUGIN_COMPONENT_NAMEServer* pA = new CoDCOMPLUGIN_COMPONENT_NAMEServer ;\r\n  if (pA == NULL)\r\n  {\r", 200);
      mBuffer.append("\n    return E_OUTOFMEMORY ;\r\n  }\r\n\r\n  // Get the requested interface.\r\n  HRESULT hr = pA->QueryInterface(iid, ppv) ;\r\n\r\n  // Release the IUnknown pointer.\r\n  // (If QueryInterface failed, component wi", 200);
      mBuffer.append("ll delete itself.)\r\n  pA->Release() ;\r\n  return hr ;\r\n}\r\n\r\n// LockServer\r\nHRESULT __stdcall CFactory::LockServer(BOOL bLock) \r\n{\r\n  if (bLock)\r\n  {\r\n    InterlockedIncrement(&g_cServerLocks) ; \r\n  }\r\n", 200);
      mBuffer.append("  else\r\n  {\r\n    InterlockedDecrement(&g_cServerLocks) ;\r\n  }\r\n  return S_OK ;\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n///////////////////////////////////////////////////////////\r\n//\r\n// Exported functions\r\n//\r\n\r\n//\r\n// Ca", 200);
      mBuffer.append("n DLL unload now\?\r\n//\r\nSTDAPI DllCanUnloadNow()\r\n{\r\n  if ((g_cComponents == 0) && (g_cServerLocks == 0))\r\n  {\r\n    return S_OK ;\r\n  }\r\n  else\r\n  {\r\n    return S_FALSE ;\r\n  }\r\n}\r\n\r\n//\r\n// Get class fac", 200);
      mBuffer.append("tory\r\n//\r\nSTDAPI DllGetClassObject(const CLSID& clsid,\r\n                         const IID& iid,\r\n                         void** ppv)\r\n{\r\n  // Can we create this component\?\r\n  if (clsid != CLSID_CoDC", 200);
      mBuffer.append("OMPLUGIN_COMPONENT_NAMEServer)\r\n  {\r\n    return CLASS_E_CLASSNOTAVAILABLE ;\r\n  }\r\n\r\n  // Create class factory.\r\n  CFactory* pFactory = new CFactory ;  // Reference count set to 1\r\n                    ", 200);
      mBuffer.append("                   // in constructor\r\n  if (pFactory == NULL)\r\n  {\r\n    return E_OUTOFMEMORY ;\r\n  }\r\n\r\n  // Get requested interface.\r\n  HRESULT hr = pFactory->QueryInterface(iid, ppv) ;\r\n  pFactory->R", 200);
      mBuffer.append("elease() ;\r\n\r\n  return hr ;\r\n}\r\n\r\n\r\n\r\n\r\nCFactory gClassFactory;\r\n\r\n\r\n\r\nDWORD CoEXEInitialize()\r\n{\r\n  DWORD nReturn;\r\n\r\n  HRESULT hr=::CoRegisterClassObject(CLSID_CoDCOMPLUGIN_COMPONENT_NAMEServer,\r\n  ", 200);
      mBuffer.append("  &gClassFactory,\r\n    CLSCTX_SERVER, \r\n    REGCLS_MULTIPLEUSE, \r\n    &nReturn);\r\n\r\n  return nReturn;\r\n}\r\n\r\nvoid CoEXEUninitialize(DWORD nToken)\r\n{\r\n  ::CoRevokeClassObject(nToken);\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n", 200);
      mBuffer.append("\r\n\r\n\r\n//\r\n// Server registration\r\n//\r\nSTDAPI DllRegisterServer()\r\n{\r\n\r\n  g_hModule = ::GetModuleHandle(NULL);\r\n\r\n  HRESULT hr= RegisterServer(g_hModule,\r\n                             g_szAppID,\r\n     ", 200);
      mBuffer.append("                        CLSID_CoDCOMPLUGIN_COMPONENT_NAMEServer,\r\n                             g_szFriendlyName,\r\n                             g_szVerIndProgID,\r\n                             g_szProgI", 200);
      mBuffer.append("D,\r\n                             LIBID_DCOMPLUGIN_LIBRARY_NAME);\r\n  if (SUCCEEDED(hr))\r\n  {\r\n    hr = RegisterTypeLib( g_hModule, NULL);\r\n  }\r\n  return hr;\r\n}\r\n\r\n\r\n//\r\n// Server unregistration\r\n//\r\nST", 200);
      mBuffer.append("DAPI DllUnregisterServer()\r\n{\r\n\r\n  g_hModule = ::GetModuleHandle(NULL);\r\n\r\n  HRESULT hr= UnregisterServer(g_hModule,\r\n                               g_szAppID,\r\n                               CLSID_Co", 200);
      mBuffer.append("DCOMPLUGIN_COMPONENT_NAMEServer,\r\n                               g_szVerIndProgID,\r\n                               g_szProgID,\r\n                               LIBID_DCOMPLUGIN_LIBRARY_NAME);\r\n  if (SU", 200);
      mBuffer.append("CCEEDED(hr))\r\n  {\r\n    UnRegisterTypeLib( g_hModule, NULL);\r\n  }\r\n  return hr;\r\n}\r\n\r\n\r\n\r\n///////////////////////////////////////////////////////////\r\n//\r\n// DLL module information\r\n//\r\nBOOL APIENTRY D", 200);
      mBuffer.append("llMain(HANDLE hModule,\r\n                      DWORD dwReason,\r\n                      void* lpReserved)\r\n{\r\n  if (dwReason == DLL_PROCESS_ATTACH)\r\n  {\r\n    g_hModule = (HMODULE)hModule ;\r\n  }\r\n\r\n  retu", 200);
      mBuffer.append("rn TRUE ;\r\n}\r\n", 14);
    }
    virtual bool save(const char * iFilename) const
    {
      FILE * f = fopen(iFilename, "wb");
      if (!f) return false;
      size_t fileSize = getSize();
      const char * buffer = getBuffer();
      fwrite(buffer, 1, fileSize, f);
      fclose(f);
      return true;
    }
  private:
    std::string mBuffer;
  };
  const File & getServerCppFile() { static ServerCppFile _instance; return _instance; }
}; //bin2cpp
