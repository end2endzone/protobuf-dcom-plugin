/**
 * This file was generated by bin2cpp v2.2.0
 * Copyright (C) 2013-2019 end2endzone.com. All rights reserved.
 * bin2cpp is open source software, see http://github.com/end2endzone/bin2cpp
 * Source code for file 'DCOMPLUGIN_COMPONENT_NAMEServer.h', last modified 1552228002.
 * Do not modify this file.
 */
#include "EmbeddedFileServerHeader.h"
#include <stdio.h> //for FILE
#include <string> //for memcpy
namespace bin2cpp
{
  class ServerHeaderFile : public virtual bin2cpp::File
  {
  public:
    ServerHeaderFile() { build(); }
    virtual ~ServerHeaderFile() {}
    virtual size_t getSize() const { return 3583; }
    virtual const char * getFilename() const { return "DCOMPLUGIN_COMPONENT_NAMEServer.h"; }
    virtual const char * getBuffer() const { return mBuffer.c_str(); }
    void build()
    {
      mBuffer.clear();
      mBuffer.reserve(getSize()); //allocate all required memory at once to prevent reallocations
      mBuffer.append("#pragma once\r\n\r\n///<summary>\r\n///DCOMPLUGIN_IDL_INTERFACE_NAMEServer interface declaration.\r\n///Implements all the required code for the COM server.\r\n///</summary>\r\nclass CoDCOMPLUGIN_COMPONENT_NAMESe", 200);
      mBuffer.append("rver : public DCOMPLUGIN_IDL_INTERFACE_NAMEServer\r\n{\r\n\r\n  // Construction\r\npublic:\r\n  CoDCOMPLUGIN_COMPONENT_NAMEServer();\r\n  ~CoDCOMPLUGIN_COMPONENT_NAMEServer();\r\n\r\n  // IUnknown interface\r\n  virtua", 200);
      mBuffer.append("l HRESULT __stdcall QueryInterface(const IID& iid, void** ppv) ;\r\n  virtual ULONG __stdcall AddRef() ;\r\n  virtual ULONG __stdcall Release() ;\r\n\r\n  // IDispatch interface\r\n  virtual HRESULT __stdcall G", 200);
      mBuffer.append("etTypeInfoCount(UINT* pctinfo);\r\n  virtual HRESULT __stdcall GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo** pptinfo);\r\n  virtual HRESULT __stdcall GetIDsOfNames(REFIID riid, LPOLESTR* rgszNames, UINT", 200);
      mBuffer.append(" cNames, LCID lcid, DISPID* rgdispid);\r\n  virtual HRESULT __stdcall Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS* pdispparams, VARIANT* pvarResult, EXCEPINFO* pexcepinfo", 200);
      mBuffer.append(", UINT* puArgErr);\r\n\r\n  // DCOMPLUGIN_IDL_INTERFACE_NAMEServer interface\r\n  DCOMPLUGIN_COCLASS_DECLARATION\r\n\r\nprivate:\r\n\r\n  // IDispatch private methods\r\n  HRESULT LoadTypeInfo(ITypeInfo ** pptinfo, c", 200);
      mBuffer.append("onst CLSID& libid, const CLSID& iid, LCID lcid);\r\n\r\n  long m_cRef;          // Reference count\r\n  LPTYPEINFO m_ptinfo;  // pointer to type-library\r\n};\r\n\r\n///<summary>Class factory for CoDCOMPLUGIN_COM", 200);
      mBuffer.append("PONENT_NAMEServer.</summary>\r\nclass CFactory : public IClassFactory\r\n{\r\npublic:\r\n  // IUnknown\r\n  virtual HRESULT __stdcall QueryInterface(const IID& iid, void** ppv) ;         \r\n  virtual ULONG   __s", 200);
      mBuffer.append("tdcall AddRef() ;\r\n  virtual ULONG   __stdcall Release() ;\r\n\r\n  // Interface IClassFactory\r\n  virtual HRESULT __stdcall CreateInstance(IUnknown* pUnknownOuter,\r\n                                       ", 200);
      mBuffer.append("    const IID& iid,\r\n                                           void** ppv) ;\r\n  virtual HRESULT __stdcall LockServer(BOOL bLock) ; \r\n\r\n  // Constructor\r\n  CFactory() : m_cRef(1) {}\r\n\r\n  // Destructor", 200);
      mBuffer.append("\r\n  ~CFactory() {;}\r\n\r\nprivate:\r\n  long m_cRef ;\r\n} ;\r\n\r\n\r\n \r\n///<summary>\r\n///Registers the CoDCOMPLUGIN_COMPONENT_NAMEServer class object with OLE (the internal COM table) so other applications can ", 200);
      mBuffer.append("connect to it.\r\n///Note that this operation has nothing to do with the registry.\r\n///</summary>\r\nDWORD CoEXEInitialize();\r\n\r\n///<summary>\r\n///Informs OLE that CoDCOMPLUGIN_COMPONENT_NAMEServer class o", 200);
      mBuffer.append("bject is no longer available for use.\r\n///Unregister the CoDCOMPLUGIN_COMPONENT_NAMEServer class object registered through CoEXEInitialize from the known table of class objects.\r\n///</summary>\r\nvoid C", 200);
      mBuffer.append("oEXEUninitialize(DWORD nToken);\r\n\r\n///<summary>\r\n///Instructs the application to create its registry entries for all classes supported in this server module.\r\n///Called when execuging \"DCOMPLUGIN_COMP", 200);
      mBuffer.append("ONENT_NAMEServer.exe /regserver\"\r\n///</summary>\r\nSTDAPI DllRegisterServer();\r\n\r\n///<summary>\r\n///Instructs the application to remove the entries created through DllRegisterServer.\r\n///Called when exec", 200);
      mBuffer.append("uging \"DCOMPLUGIN_COMPONENT_NAMEServer.exe /unregserver\"\r\n///</summary>\r\nSTDAPI DllUnregisterServer();\r\n\r\n///<summary>\r\n///Instructs the application to create its registry entries for all classes supp", 200);
      mBuffer.append("orted in this server module.\r\n///Called when execuging \"DCOMPLUGIN_COMPONENT_NAMEServer.exe /regserver\"\r\n///</summary>\r\nSTDAPI RegisterApplicationId();\r\n\r\n///<summary>\r\n///Instructs the application to", 200);
      mBuffer.append(" remove the entries created through DllRegisterServer.\r\n///Called when execuging \"DCOMPLUGIN_COMPONENT_NAMEServer.exe /unregserver\"\r\n///</summary>\r\nSTDAPI UnregisterApplicationId();\r\n", 183);
    }
    virtual bool save(const char * iFilename) const
    {
      FILE * f = fopen(iFilename, "wb");
      if (!f) return false;
      size_t fileSize = getSize();
      const char * buffer = getBuffer();
      fwrite(buffer, 1, fileSize, f);
      fclose(f);
      return true;
    }
  private:
    std::string mBuffer;
  };
  const File & getServerHeaderFile() { static ServerHeaderFile _instance; return _instance; }
}; //bin2cpp
