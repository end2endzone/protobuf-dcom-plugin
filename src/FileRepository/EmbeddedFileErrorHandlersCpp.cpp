/**
 * This file was generated by
 * bin2cpp v1.3.
 * Copyright (C) 2013-2014 end2endzone.com. All rights reserved.
 * Do not modify this file.
 */
#include ".\EmbeddedFileErrorHandlersCpp.h"
#include <stdio.h> //for FILE
#include <string> //for memcpy
namespace bin2cpp
{
  class ErrorHandlersCppFile : public virtual bin2cpp::File
  {
  public:
    ErrorHandlersCppFile() {}
    ~ErrorHandlersCppFile() {}
    virtual size_t getSize() { return 3499; }
    virtual size_t getSegmentSize() { return 200; }
    virtual size_t getNumSegments() { return 18; }
    virtual const char * getFilename() { return "ErrorHandlers.cpp"; }
    virtual const char * getSegment(size_t iIndex, size_t & oLength)
    {
      oLength = 0;
      if (iIndex >= getNumSegments())
        return NULL;
      const char * buffer = NULL;
      size_t index = 0;
      oLength = getSegmentSize();
      buffer = "#include \"ErrorHandlers.h\"\x0d\x0a\x0d\012#include <comdef.h>\x0d\x0a\x0d\012namespace DCOMPLUGIN_PACKAGE_NAME {\x0d\x0a\x0d\012std::string getProcessFilename()                           \x0d\012{                                              "; if (iIndex == index) return buffer; index++;
      buffer = "                   \x0d\012  std::string path;                                               \x0d\012  char buffer[MAX_PATH] = {0};                                    \x0d\012  HMODULE hModule = NULL;                  "; if (iIndex == index) return buffer; index++;
      buffer = "                       \x0d\012  if (!GetModuleHandleEx(GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS | \x0d\012          GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT,           \x0d\012          (LPCSTR) __FUNCTION__,   \x0d\012  "; if (iIndex == index) return buffer; index++;
      buffer = "        &hModule))                                              \x0d\012  {                                                               \x0d\012      int ret = GetLastError();                                   "; if (iIndex == index) return buffer; index++;
      buffer = "\x0d\012      return std::string();                                       \x0d\012  }                                                               \x0d\012  /*get the path of this DLL*/                                "; if (iIndex == index) return buffer; index++;
      buffer = "    \x0d\012  GetModuleFileName(hModule, buffer, sizeof(buffer));             \x0d\012  if (buffer[0] != '\\0')                                          \x0d\012  {                                                       "; if (iIndex == index) return buffer; index++;
      buffer = "        \x0d\012    /*remove folders from path*/                                     \x0d\012    path = buffer;                                                \x0d\012    while(path.find(\"/\") != std::string::npos)\x0d\012   "; if (iIndex == index) return buffer; index++;
      buffer = " {\x0d\012      path.erase(path.begin(), path.begin()+1);\x0d\012    }\x0d\012    while(path.find(\"\\\\\") != std::string::npos)\x0d\012    {\x0d\012      path.erase(path.begin(), path.begin()+1);\x0d\012    }\x0d\012  }                         "; if (iIndex == index) return buffer; index++;
      buffer = "                                      \x0d\012  return path;                                                    \x0d\012}\x0d\x0a\x0d\012std::string toString(DWORD value)\x0d\012{\x0d\012  static const int BUFFER_SIZE = 1024;\x0d\012  char bu"; if (iIndex == index) return buffer; index++;
      buffer = "ffer[BUFFER_SIZE];\x0d\012  sprintf(buffer, \"%lu\", value);\x0d\012  std::string str = buffer;\x0d\012  return str;\x0d\012}\x0d\x0a\x0d\012void MessageBoxLastError()\x0d\012{\x0d\012  DWORD dwErrorCode = GetLastError();\x0d\x0a\x0d\012  LPVOID lpMessageBuffer;"; if (iIndex == index) return buffer; index++;
      buffer = " \x0d\012  FormatMessage( \x0d\012    FORMAT_MESSAGE_ALLOCATE_BUFFER |\x0d\012    FORMAT_MESSAGE_FROM_SYSTEM,\x0d\012    NULL,\x0d\012    dwErrorCode,\x0d\012    MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), //The user default language\x0d\012  "; if (iIndex == index) return buffer; index++;
      buffer = "  (LPTSTR) &lpMessageBuffer,\x0d\012    1,\x0d\012    NULL \x0d\012  );\x0d\x0a\x0d\012  std::string caption;\x0d\012  caption += getProcessFilename();\x0d\012  std::string message;\x0d\012  message += \"An internal error occured in process \";\x0d\012  me"; if (iIndex == index) return buffer; index++;
      buffer = "ssage += getProcessFilename();\x0d\012  message += \"\\n\";\x0d\012  message += \"\\n\";\x0d\012  message += \"Error code: \";\x0d\012  message += toString(dwErrorCode);\x0d\012  message += \"\\n\";\x0d\012  message += \"Error desc: \";\x0d\012  message +"; if (iIndex == index) return buffer; index++;
      buffer = "= (LPTSTR)lpMessageBuffer;\x0d\x0a\x0d\012  MessageBox(NULL, message.c_str(), caption.c_str(), MB_OK | MB_ICONERROR);\x0d\012  LocalFree(lpMessageBuffer);\x0d\012}\x0d\x0a\x0d\012void MessageBoxLastComError(HRESULT hr)\x0d\012{\x0d\012  _com_error "; if (iIndex == index) return buffer; index++;
      buffer = "err(hr);\x0d\012  LPCTSTR lpMessageBuffer = err.ErrorMessage();\x0d\x0a\x0d\012  std::string caption;\x0d\012  caption += getProcessFilename();\x0d\012  std::string message;\x0d\012  message += \"An internal error occured in process \";\x0d\x0a"; if (iIndex == index) return buffer; index++;
      buffer = "  message += getProcessFilename();\x0d\012  message += \"\\n\";\x0d\012  message += \"\\n\";\x0d\012  message += \"Error code: \";\x0d\012  message += toString(hr);\x0d\012  message += \"\\n\";\x0d\012  message += \"Error desc: \";\x0d\012  message += (LP"; if (iIndex == index) return buffer; index++;
      buffer = "TSTR)lpMessageBuffer;\x0d\x0a\x0d\012  MessageBox(NULL, message.c_str(), caption.c_str(), MB_OK | MB_ICONERROR);\x0d\012}\x0d\x0a\x0d\012std::string GetComErrorDescription(HRESULT hr)\x0d\012{\x0d\012  _com_error err(hr);\x0d\012  std::string descr"; if (iIndex == index) return buffer; index++;
      oLength = 99;
      buffer = "iption = err.ErrorMessage();\x0d\012  return description;\x0d\012}\x0d\x0a\x0d\012}  // namespace DCOMPLUGIN_PACKAGE_NAME\x0d\x0a"; if (iIndex == index) return buffer; index++;
      oLength = 0;
      return NULL;
    }
    virtual const char * getMd5() { return "6ac0fe1a6e9386ba5632cdfb95184897"; }
    virtual char * newBuffer()
    {
      size_t size = getSize();
      char * buffer = new char[size];
      if (buffer == NULL)
        return NULL;
      size_t numSegments = getNumSegments();
      size_t segmentLength = 0;
      size_t index = 0;
      for(size_t i=0; i<numSegments; i++)
      {
        const char * segmentBuffer = getSegment(i, segmentLength);
        memcpy(&buffer[index], segmentBuffer, segmentLength);
        index += segmentLength;
      }
      return buffer;
    }
    virtual bool save(const char * iFilename)
    {
      FILE * f = fopen(iFilename, "wb");
      if (!f) return false;
      size_t numSegments = getNumSegments();
      size_t segmentLength = 0;
      const char * buffer = NULL;
      for(size_t i=0; i<numSegments; i++)
      {
        buffer = getSegment(i, segmentLength);
        fwrite(buffer, 1, segmentLength, f);
      }
      fclose(f);
      return true;
    }
  };
  File & getErrorHandlersCppFile() { static ErrorHandlersCppFile _instance; return _instance; }
}; //bin2cpp
