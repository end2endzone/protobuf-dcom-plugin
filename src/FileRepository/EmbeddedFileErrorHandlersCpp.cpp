/**
 * This file was generated by bin2cpp v2.2.0
 * Copyright (C) 2013-2019 end2endzone.com. All rights reserved.
 * bin2cpp is open source software, see http://github.com/end2endzone/bin2cpp
 * Source code for file 'ErrorHandlers.cpp', last modified 1552228002.
 * Do not modify this file.
 */
#include "EmbeddedFileErrorHandlersCpp.h"
#include <stdio.h> //for FILE
#include <string> //for memcpy
namespace bin2cpp
{
  class ErrorHandlersCppFile : public virtual bin2cpp::File
  {
  public:
    ErrorHandlersCppFile() { build(); }
    virtual ~ErrorHandlersCppFile() {}
    virtual size_t getSize() const { return 3499; }
    virtual const char * getFilename() const { return "ErrorHandlers.cpp"; }
    virtual const char * getBuffer() const { return mBuffer.c_str(); }
    void build()
    {
      mBuffer.clear();
      mBuffer.reserve(getSize()); //allocate all required memory at once to prevent reallocations
      mBuffer.append("#include \"ErrorHandlers.h\"\r\n\r\n#include <comdef.h>\r\n\r\nnamespace DCOMPLUGIN_PACKAGE_NAME {\r\n\r\nstd::string getProcessFilename()                           \r\n{                                              ", 200);
      mBuffer.append("                   \r\n  std::string path;                                               \r\n  char buffer[MAX_PATH] = {0};                                    \r\n  HMODULE hModule = NULL;                  ", 200);
      mBuffer.append("                       \r\n  if (!GetModuleHandleEx(GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS | \r\n          GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT,           \r\n          (LPCSTR) __FUNCTION__,   \r\n  ", 200);
      mBuffer.append("        &hModule))                                              \r\n  {                                                               \r\n      int ret = GetLastError();                                   ", 200);
      mBuffer.append("\r\n      return std::string();                                       \r\n  }                                                               \r\n  /*get the path of this DLL*/                                ", 200);
      mBuffer.append("    \r\n  GetModuleFileName(hModule, buffer, sizeof(buffer));             \r\n  if (buffer[0] != \'\\0\')                                          \r\n  {                                                       ", 200);
      mBuffer.append("        \r\n    /*remove folders from path*/                                     \r\n    path = buffer;                                                \r\n    while(path.find(\"/\") != std::string::npos)\r\n   ", 200);
      mBuffer.append(" {\r\n      path.erase(path.begin(), path.begin()+1);\r\n    }\r\n    while(path.find(\"\\\\\") != std::string::npos)\r\n    {\r\n      path.erase(path.begin(), path.begin()+1);\r\n    }\r\n  }                         ", 200);
      mBuffer.append("                                      \r\n  return path;                                                    \r\n}\r\n\r\nstd::string toString(DWORD value)\r\n{\r\n  static const int BUFFER_SIZE = 1024;\r\n  char bu", 200);
      mBuffer.append("ffer[BUFFER_SIZE];\r\n  sprintf(buffer, \"%lu\", value);\r\n  std::string str = buffer;\r\n  return str;\r\n}\r\n\r\nvoid MessageBoxLastError()\r\n{\r\n  DWORD dwErrorCode = GetLastError();\r\n\r\n  LPVOID lpMessageBuffer;", 200);
      mBuffer.append(" \r\n  FormatMessage( \r\n    FORMAT_MESSAGE_ALLOCATE_BUFFER |\r\n    FORMAT_MESSAGE_FROM_SYSTEM,\r\n    NULL,\r\n    dwErrorCode,\r\n    MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), //The user default language\r\n  ", 200);
      mBuffer.append("  (LPTSTR) &lpMessageBuffer,\r\n    1,\r\n    NULL \r\n  );\r\n\r\n  std::string caption;\r\n  caption += getProcessFilename();\r\n  std::string message;\r\n  message += \"An internal error occured in process \";\r\n  me", 200);
      mBuffer.append("ssage += getProcessFilename();\r\n  message += \"\\n\";\r\n  message += \"\\n\";\r\n  message += \"Error code: \";\r\n  message += toString(dwErrorCode);\r\n  message += \"\\n\";\r\n  message += \"Error desc: \";\r\n  message +", 200);
      mBuffer.append("= (LPTSTR)lpMessageBuffer;\r\n\r\n  MessageBox(NULL, message.c_str(), caption.c_str(), MB_OK | MB_ICONERROR);\r\n  LocalFree(lpMessageBuffer);\r\n}\r\n\r\nvoid MessageBoxLastComError(HRESULT hr)\r\n{\r\n  _com_error ", 200);
      mBuffer.append("err(hr);\r\n  LPCTSTR lpMessageBuffer = err.ErrorMessage();\r\n\r\n  std::string caption;\r\n  caption += getProcessFilename();\r\n  std::string message;\r\n  message += \"An internal error occured in process \";\r\n", 200);
      mBuffer.append("  message += getProcessFilename();\r\n  message += \"\\n\";\r\n  message += \"\\n\";\r\n  message += \"Error code: \";\r\n  message += toString(hr);\r\n  message += \"\\n\";\r\n  message += \"Error desc: \";\r\n  message += (LP", 200);
      mBuffer.append("TSTR)lpMessageBuffer;\r\n\r\n  MessageBox(NULL, message.c_str(), caption.c_str(), MB_OK | MB_ICONERROR);\r\n}\r\n\r\nstd::string GetComErrorDescription(HRESULT hr)\r\n{\r\n  _com_error err(hr);\r\n  std::string descr", 200);
      mBuffer.append("iption = err.ErrorMessage();\r\n  return description;\r\n}\r\n\r\n}  // namespace DCOMPLUGIN_PACKAGE_NAME\r\n", 99);
    }
    virtual bool save(const char * iFilename) const
    {
      FILE * f = fopen(iFilename, "wb");
      if (!f) return false;
      size_t fileSize = getSize();
      const char * buffer = getBuffer();
      fwrite(buffer, 1, fileSize, f);
      fclose(f);
      return true;
    }
  private:
    std::string mBuffer;
  };
  const File & getErrorHandlersCppFile() { static ErrorHandlersCppFile _instance; return _instance; }
}; //bin2cpp
